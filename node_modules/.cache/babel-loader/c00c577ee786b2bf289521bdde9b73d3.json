{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _lodash = require(\"lodash\");\n\nvar _bluebird = _interopRequireDefault(require(\"bluebird\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar PassThrough; // The \"Runner\" constructor takes a \"builder\" (query, schema, or raw)\n// and runs through each of the query statements, calling any additional\n// \"output\" method provided alongside the query and bindings.\n\nfunction Runner(client, builder) {\n  this.client = client;\n  this.builder = builder;\n  this.queries = []; // The \"connection\" object is set on the runner when\n  // \"run\" is called.\n\n  this.connection = void 0;\n}\n\n(0, _lodash.assign)(Runner.prototype, {\n  // \"Run\" the target, calling \"toSQL\" on the builder, returning\n  // an object or array of queries to run, each of which are run on\n  // a single connection.\n  run: function run() {\n    var runner = this;\n    return _bluebird.default.using(this.ensureConnection(), function (connection) {\n      runner.connection = connection;\n      runner.client.emit('start', runner.builder);\n      runner.builder.emit('start', runner.builder);\n      var sql = runner.builder.toSQL();\n\n      if (runner.builder._debug) {\n        runner.client.logger.debug(sql);\n      }\n\n      if ((0, _lodash.isArray)(sql)) {\n        return runner.queryArray(sql);\n      }\n\n      return runner.query(sql);\n    }) // If there are any \"error\" listeners, we fire an error event\n    // and then re-throw the error to be eventually handled by\n    // the promise chain. Useful if you're wrapping in a custom `Promise`.\n    .catch(function (err) {\n      if (runner.builder._events && runner.builder._events.error) {\n        runner.builder.emit('error', err);\n      }\n\n      throw err;\n    }) // Fire a single \"end\" event on the builder when\n    // all queries have successfully completed.\n    .tap(function () {\n      runner.builder.emit('end');\n    });\n  },\n  // Stream the result set, by passing through to the dialect's streaming\n  // capabilities. If the options are\n  stream: function stream(options, handler) {\n    // If we specify stream(handler).then(...\n    if (arguments.length === 1) {\n      if (typeof options === 'function') {\n        handler = options;\n        options = {};\n      }\n    } // Determines whether we emit an error or throw here.\n\n\n    var hasHandler = typeof handler === 'function'; // Lazy-load the \"PassThrough\" dependency.\n\n    PassThrough = PassThrough || require('stream').PassThrough;\n    var runner = this;\n    var stream = new PassThrough({\n      objectMode: true\n    });\n    var hasConnection = false;\n\n    var promise = _bluebird.default.using(this.ensureConnection(), function (connection) {\n      hasConnection = true;\n      runner.connection = connection;\n\n      try {\n        var sql = runner.builder.toSQL();\n\n        if ((0, _lodash.isArray)(sql) && hasHandler) {\n          throw new Error('The stream may only be used with a single query statement.');\n        }\n\n        return runner.client.stream(runner.connection, sql, stream, options);\n      } catch (e) {\n        stream.emit('error', e);\n        throw e;\n      }\n    }); // If a function is passed to handle the stream, send the stream\n    // there and return the promise, otherwise just return the stream\n    // and the promise will take care of itself.\n\n\n    if (hasHandler) {\n      handler(stream);\n      return promise;\n    } // Emit errors on the stream if the error occurred before a connection\n    // could be acquired.\n    // If the connection was acquired, assume the error occurred in the client\n    // code and has already been emitted on the stream. Don't emit it twice.\n\n\n    promise.catch(function (err) {\n      if (!hasConnection) stream.emit('error', err);\n    });\n    return stream;\n  },\n  // Allow you to pipe the stream to a writable stream.\n  pipe: function pipe(writable, options) {\n    return this.stream(options).pipe(writable);\n  },\n  // \"Runs\" a query, returning a promise. All queries specified by the builder are guaranteed\n  // to run in sequence, and on the same connection, especially helpful when schema building\n  // and dealing with foreign key constraints, etc.\n  query: _bluebird.default.method(function (obj) {\n    var _this = this;\n\n    var _this$connection = this.connection,\n        __knexUid = _this$connection.__knexUid,\n        __knexTxId = _this$connection.__knexTxId;\n    this.builder.emit('query', (0, _lodash.assign)({\n      __knexUid: __knexUid,\n      __knexTxId: __knexTxId\n    }, obj));\n    var runner = this;\n    var queryPromise = this.client.query(this.connection, obj);\n\n    if (obj.timeout) {\n      queryPromise = queryPromise.timeout(obj.timeout);\n    }\n\n    return queryPromise.then(function (resp) {\n      var processedResponse = _this.client.processResponse(resp, runner);\n\n      var queryContext = _this.builder.queryContext();\n\n      var postProcessedResponse = _this.client.postProcessResponse(processedResponse, queryContext);\n\n      _this.builder.emit('query-response', postProcessedResponse, (0, _lodash.assign)({\n        __knexUid: _this.connection.__knexUid\n      }, obj), _this.builder);\n\n      _this.client.emit('query-response', postProcessedResponse, (0, _lodash.assign)({\n        __knexUid: _this.connection.__knexUid\n      }, obj), _this.builder);\n\n      return postProcessedResponse;\n    }).catch(_bluebird.default.TimeoutError, function (error) {\n      var timeout = obj.timeout,\n          sql = obj.sql,\n          bindings = obj.bindings;\n      var cancelQuery;\n\n      if (obj.cancelOnTimeout) {\n        cancelQuery = _this.client.cancelQuery(_this.connection);\n      } else {\n        // If we don't cancel the query, we need to mark the connection as disposed so that\n        // it gets destroyed by the pool and is never used again. If we don't do this and\n        // return the connection to the pool, it will be useless until the current operation\n        // that timed out, finally finishes.\n        _this.connection.__knex__disposed = error;\n        cancelQuery = _bluebird.default.resolve();\n      }\n\n      return cancelQuery.catch(function (cancelError) {\n        // If the cancellation failed, we need to mark the connection as disposed so that\n        // it gets destroyed by the pool and is never used again. If we don't do this and\n        // return the connection to the pool, it will be useless until the current operation\n        // that timed out, finally finishes.\n        _this.connection.__knex__disposed = error; // cancellation failed\n\n        throw (0, _lodash.assign)(cancelError, {\n          message: \"After query timeout of \".concat(timeout, \"ms exceeded, cancelling of query failed.\"),\n          sql: sql,\n          bindings: bindings,\n          timeout: timeout\n        });\n      }).then(function () {\n        // cancellation succeeded, rethrow timeout error\n        throw (0, _lodash.assign)(error, {\n          message: \"Defined query timeout of \".concat(timeout, \"ms exceeded when running query.\"),\n          sql: sql,\n          bindings: bindings,\n          timeout: timeout\n        });\n      });\n    }).catch(function (error) {\n      _this.builder.emit('query-error', error, (0, _lodash.assign)({\n        __knexUid: _this.connection.__knexUid\n      }, obj));\n\n      throw error;\n    });\n  }),\n  // In the case of the \"schema builder\" we call `queryArray`, which runs each\n  // of the queries in sequence.\n  queryArray: function queryArray(queries) {\n    return queries.length === 1 ? this.query(queries[0]) : _bluebird.default.bind(this).return(queries).reduce(function (memo, query) {\n      return this.query(query).then(function (resp) {\n        memo.push(resp);\n        return memo;\n      });\n    }, []);\n  },\n  // Check whether there's a transaction flag, and that it has a connection.\n  ensureConnection: function ensureConnection() {\n    var _this2 = this;\n\n    // Use override from a builder if passed\n    if (this.builder._connection) {\n      return _bluebird.default.resolve(this.builder._connection);\n    }\n\n    if (this.connection) {\n      return _bluebird.default.resolve(this.connection);\n    }\n\n    return this.client.acquireConnection().catch(_bluebird.default.TimeoutError, function (error) {\n      if (_this2.builder) {\n        error.sql = _this2.builder.sql;\n        error.bindings = _this2.builder.bindings;\n      }\n\n      throw error;\n    }).disposer(function () {\n      // need to return promise or null from handler to prevent warning from bluebird\n      return _this2.client.releaseConnection(_this2.connection);\n    });\n  }\n});\nvar _default = Runner;\nexports.default = _default;\nmodule.exports = exports.default;","map":null,"metadata":{},"sourceType":"script"}