{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _inherits = _interopRequireDefault(require(\"inherits\"));\n\nvar _compiler = _interopRequireDefault(require(\"../../../query/compiler\"));\n\nvar _lodash = require(\"lodash\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // MySQL Query Compiler\n// ------\n\n\nfunction QueryCompiler_MySQL(client, builder) {\n  _compiler.default.call(this, client, builder);\n}\n\n(0, _inherits.default)(QueryCompiler_MySQL, _compiler.default);\n(0, _lodash.assign)(QueryCompiler_MySQL.prototype, {\n  _emptyInsertValue: '() values ()',\n  // Update method, including joins, wheres, order & limits.\n  update: function update() {\n    var join = this.join();\n\n    var updates = this._prepUpdate(this.single.update);\n\n    var where = this.where();\n    var order = this.order();\n    var limit = this.limit();\n    return \"update \".concat(this.tableName) + (join ? \" \".concat(join) : '') + ' set ' + updates.join(', ') + (where ? \" \".concat(where) : '') + (order ? \" \".concat(order) : '') + (limit ? \" \".concat(limit) : '');\n  },\n  forUpdate: function forUpdate() {\n    return 'for update';\n  },\n  forShare: function forShare() {\n    return 'lock in share mode';\n  },\n  // Compiles a `columnInfo` query.\n  columnInfo: function columnInfo() {\n    var column = this.single.columnInfo; // The user may have specified a custom wrapIdentifier function in the config. We\n    // need to run the identifiers through that function, but not format them as\n    // identifiers otherwise.\n\n    var table = this.client.customWrapIdentifier(this.single.table, _lodash.identity);\n    return {\n      sql: 'select * from information_schema.columns where table_name = ? and table_schema = ?',\n      bindings: [table, this.client.database()],\n      output: function output(resp) {\n        var out = resp.reduce(function (columns, val) {\n          columns[val.COLUMN_NAME] = {\n            defaultValue: val.COLUMN_DEFAULT,\n            type: val.DATA_TYPE,\n            maxLength: val.CHARACTER_MAXIMUM_LENGTH,\n            nullable: val.IS_NULLABLE === 'YES'\n          };\n          return columns;\n        }, {});\n        return column && out[column] || out;\n      }\n    };\n  },\n  limit: function limit() {\n    var noLimit = !this.single.limit && this.single.limit !== 0;\n    if (noLimit && !this.single.offset) return ''; // Workaround for offset only.\n    // see: http://stackoverflow.com/questions/255517/mysql-offset-infinite-rows\n\n    var limit = this.single.offset && noLimit ? '18446744073709551615' : this.formatter.parameter(this.single.limit);\n    return \"limit \".concat(limit);\n  }\n}); // Set the QueryBuilder & QueryCompiler on the client object,\n// in case anyone wants to modify things to suit their own purposes.\n\nvar _default = QueryCompiler_MySQL;\nexports.default = _default;\nmodule.exports = exports.default;","map":null,"metadata":{},"sourceType":"script"}