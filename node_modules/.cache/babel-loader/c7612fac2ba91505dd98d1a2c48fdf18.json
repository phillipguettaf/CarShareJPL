{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _fs = _interopRequireDefault(require(\"fs\"));\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _mkdirp = _interopRequireDefault(require(\"mkdirp\"));\n\nvar _bluebird = _interopRequireDefault(require(\"bluebird\"));\n\nvar _lodash = require(\"lodash\");\n\nvar _Migrator = require(\"./Migrator\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar MigrationGenerator =\n/*#__PURE__*/\nfunction () {\n  function MigrationGenerator(migrationConfig) {\n    _classCallCheck(this, MigrationGenerator);\n\n    this.config = (0, _Migrator.getMergedConfig)(migrationConfig);\n  } // Creates a new migration, with a given name.\n\n\n  _createClass(MigrationGenerator, [{\n    key: \"make\",\n    value: function make(name, config) {\n      var _this = this;\n\n      this.config = (0, _Migrator.getMergedConfig)(config, this.config);\n\n      if (!name) {\n        return _bluebird.default.reject(new Error('A name must be specified for the generated migration'));\n      }\n\n      return this._ensureFolder(config).then(function (val) {\n        return _this._generateStubTemplate(val);\n      }).then(function (val) {\n        return _this._writeNewMigration(name, val);\n      });\n    } // Ensures a folder for the migrations exist, dependent on the migration\n    // config settings.\n\n  }, {\n    key: \"_ensureFolder\",\n    value: function _ensureFolder() {\n      var dirs = this._absoluteConfigDirs();\n\n      var promises = dirs.map(function (dir) {\n        return _bluebird.default.promisify(_fs.default.stat, {\n          context: _fs.default\n        })(dir).catch(function () {\n          return _bluebird.default.promisify(_mkdirp.default)(dir);\n        });\n      });\n      return _bluebird.default.all(promises);\n    } // Generates the stub template for the current migration, returning a compiled\n    // template.\n\n  }, {\n    key: \"_generateStubTemplate\",\n    value: function _generateStubTemplate() {\n      var stubPath = this.config.stub || _path.default.join(__dirname, 'stub', this.config.extension + '.stub');\n\n      return _bluebird.default.promisify(_fs.default.readFile, {\n        context: _fs.default\n      })(stubPath).then(function (stub) {\n        return (0, _lodash.template)(stub.toString(), {\n          variable: 'd'\n        });\n      });\n    } // Write a new migration to disk, using the config and generated filename,\n    // passing any `variables` given in the config to the template.\n\n  }, {\n    key: \"_writeNewMigration\",\n    value: function _writeNewMigration(name, tmpl) {\n      var config = this.config;\n\n      var dirs = this._absoluteConfigDirs();\n\n      var dir = dirs.slice(-1)[0]; // Get last specified directory\n\n      if (name[0] === '-') name = name.slice(1);\n      var filename = yyyymmddhhmmss() + '_' + name + '.' + config.extension;\n      return _bluebird.default.promisify(_fs.default.writeFile, {\n        context: _fs.default\n      })(_path.default.join(dir, filename), tmpl(config.variables || {})).return(_path.default.join(dir, filename));\n    }\n  }, {\n    key: \"_absoluteConfigDirs\",\n    value: function _absoluteConfigDirs() {\n      var directories = Array.isArray(this.config.directory) ? this.config.directory : [this.config.directory];\n      return directories.map(function (directory) {\n        return _path.default.resolve(process.cwd(), directory);\n      });\n    }\n  }]);\n\n  return MigrationGenerator;\n}(); // Ensure that we have 2 places for each of the date segments.\n\n\nexports.default = MigrationGenerator;\n\nfunction padDate(segment) {\n  segment = segment.toString();\n  return segment[1] ? segment : \"0\".concat(segment);\n} // Get a date object in the correct format, without requiring a full out library\n// like \"moment.js\".\n\n\nfunction yyyymmddhhmmss() {\n  var d = new Date();\n  return d.getFullYear().toString() + padDate(d.getMonth() + 1) + padDate(d.getDate()) + padDate(d.getHours()) + padDate(d.getMinutes()) + padDate(d.getSeconds());\n}\n\nmodule.exports = exports.default;","map":null,"metadata":{},"sourceType":"script"}