{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _inherits = _interopRequireDefault(require(\"inherits\"));\n\nvar _compiler = _interopRequireDefault(require(\"../../../query/compiler\"));\n\nvar _lodash = require(\"lodash\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // PostgreSQL Query Builder & Compiler\n// ------\n\n\nfunction QueryCompiler_PG(client, builder) {\n  _compiler.default.call(this, client, builder);\n}\n\n(0, _inherits.default)(QueryCompiler_PG, _compiler.default);\n(0, _lodash.assign)(QueryCompiler_PG.prototype, {\n  // Compiles a truncate query.\n  truncate: function truncate() {\n    return \"truncate \".concat(this.tableName, \" restart identity\");\n  },\n  // is used if the an array with multiple empty values supplied\n  _defaultInsertValue: 'default',\n  // Compiles an `insert` query, allowing for multiple\n  // inserts using a single query statement.\n  insert: function insert() {\n    var sql = _compiler.default.prototype.insert.call(this);\n\n    if (sql === '') return sql;\n    var returning = this.single.returning;\n    return {\n      sql: sql + this._returning(returning),\n      returning: returning\n    };\n  },\n  // Compiles an `update` query, allowing for a return value.\n  update: function update() {\n    var withSQL = this.with();\n\n    var updateData = this._prepUpdate(this.single.update);\n\n    var wheres = this.where();\n    var returning = this.single.returning;\n    return {\n      sql: withSQL + \"update \".concat(this.single.only ? 'only ' : '').concat(this.tableName, \" \") + \"set \".concat(updateData.join(', ')) + (wheres ? \" \".concat(wheres) : '') + this._returning(returning),\n      returning: returning\n    };\n  },\n  // Compiles an `update` query, allowing for a return value.\n  del: function del() {\n    var sql = _compiler.default.prototype.del.apply(this, arguments);\n\n    var returning = this.single.returning;\n    return {\n      sql: sql + this._returning(returning),\n      returning: returning\n    };\n  },\n  aggregate: function aggregate(stmt) {\n    return this._aggregate(stmt, {\n      distinctParentheses: true\n    });\n  },\n  _returning: function _returning(value) {\n    return value ? \" returning \".concat(this.formatter.columnize(value)) : '';\n  },\n  // Join array of table names and apply default schema.\n  _tableNames: function _tableNames(tables) {\n    var schemaName = this.single.schema;\n    var sql = [];\n\n    for (var i = 0; i < tables.length; i++) {\n      var tableName = tables[i];\n\n      if (tableName) {\n        if (schemaName) {\n          tableName = \"\".concat(schemaName, \".\").concat(tableName);\n        }\n\n        sql.push(this.formatter.wrap(tableName));\n      }\n    }\n\n    return sql.join(', ');\n  },\n  forUpdate: function forUpdate() {\n    var tables = this.single.lockTables || [];\n    return 'for update' + (tables.length ? ' of ' + this._tableNames(tables) : '');\n  },\n  forShare: function forShare() {\n    var tables = this.single.lockTables || [];\n    return 'for share' + (tables.length ? ' of ' + this._tableNames(tables) : '');\n  },\n  // Compiles a columnInfo query\n  columnInfo: function columnInfo() {\n    var column = this.single.columnInfo;\n    var schema = this.single.schema; // The user may have specified a custom wrapIdentifier function in the config. We\n    // need to run the identifiers through that function, but not format them as\n    // identifiers otherwise.\n\n    var table = this.client.customWrapIdentifier(this.single.table, _lodash.identity);\n\n    if (schema) {\n      schema = this.client.customWrapIdentifier(schema, _lodash.identity);\n    }\n\n    var sql = 'select * from information_schema.columns where table_name = ? and table_catalog = ?';\n    var bindings = [table, this.client.database()];\n\n    if (schema) {\n      sql += ' and table_schema = ?';\n      bindings.push(schema);\n    } else {\n      sql += ' and table_schema = current_schema()';\n    }\n\n    return {\n      sql: sql,\n      bindings: bindings,\n      output: function output(resp) {\n        var out = (0, _lodash.reduce)(resp.rows, function (columns, val) {\n          columns[val.column_name] = {\n            type: val.data_type,\n            maxLength: val.character_maximum_length,\n            nullable: val.is_nullable === 'YES',\n            defaultValue: val.column_default\n          };\n          return columns;\n        }, {});\n        return column && out[column] || out;\n      }\n    };\n  }\n});\nvar _default = QueryCompiler_PG;\nexports.default = _default;\nmodule.exports = exports.default;","map":null,"metadata":{},"sourceType":"script"}