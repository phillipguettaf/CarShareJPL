{"ast":null,"code":"\"use strict\";\n\nvar _construct = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/construct\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _lodash = require(\"lodash\");\n\nvar _inherits = _interopRequireDefault(require(\"inherits\"));\n\nvar _client = _interopRequireDefault(require(\"../../client\"));\n\nvar _bluebird = _interopRequireDefault(require(\"bluebird\"));\n\nvar _compiler = _interopRequireDefault(require(\"./query/compiler\"));\n\nvar _columncompiler = _interopRequireDefault(require(\"./schema/columncompiler\"));\n\nvar _tablecompiler = _interopRequireDefault(require(\"./schema/tablecompiler\"));\n\nvar _compiler2 = _interopRequireDefault(require(\"./schema/compiler\"));\n\nvar _string = require(\"../../query/string\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // PostgreSQL\n// -------\n\n\nfunction Client_PG(config) {\n  _client.default.apply(this, arguments);\n\n  if (config.returning) {\n    this.defaultReturning = config.returning;\n  }\n\n  if (config.searchPath) {\n    this.searchPath = config.searchPath;\n  }\n}\n\n(0, _inherits.default)(Client_PG, _client.default);\n(0, _lodash.assign)(Client_PG.prototype, {\n  queryCompiler: function queryCompiler() {\n    return _construct(_compiler.default, [this].concat(Array.prototype.slice.call(arguments)));\n  },\n  columnCompiler: function columnCompiler() {\n    return _construct(_columncompiler.default, [this].concat(Array.prototype.slice.call(arguments)));\n  },\n  schemaCompiler: function schemaCompiler() {\n    return _construct(_compiler2.default, [this].concat(Array.prototype.slice.call(arguments)));\n  },\n  tableCompiler: function tableCompiler() {\n    return _construct(_tablecompiler.default, [this].concat(Array.prototype.slice.call(arguments)));\n  },\n  dialect: 'postgresql',\n  driverName: 'pg',\n  _driver: function _driver() {\n    return require('pg');\n  },\n  _escapeBinding: (0, _string.makeEscape)({\n    escapeArray: function escapeArray(val, esc) {\n      return esc(arrayString(val, esc));\n    },\n    escapeString: function escapeString(str) {\n      var hasBackslash = false;\n      var escaped = \"'\";\n\n      for (var i = 0; i < str.length; i++) {\n        var c = str[i];\n\n        if (c === \"'\") {\n          escaped += c + c;\n        } else if (c === '\\\\') {\n          escaped += c + c;\n          hasBackslash = true;\n        } else {\n          escaped += c;\n        }\n      }\n\n      escaped += \"'\";\n\n      if (hasBackslash === true) {\n        escaped = 'E' + escaped;\n      }\n\n      return escaped;\n    },\n    escapeObject: function escapeObject(val, prepareValue, timezone) {\n      var seen = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n      if (val && typeof val.toPostgres === 'function') {\n        seen = seen || [];\n\n        if (seen.indexOf(val) !== -1) {\n          throw new Error(\"circular reference detected while preparing \\\"\".concat(val, \"\\\" for query\"));\n        }\n\n        seen.push(val);\n        return prepareValue(val.toPostgres(prepareValue), seen);\n      }\n\n      return JSON.stringify(val);\n    }\n  }),\n  wrapIdentifierImpl: function wrapIdentifierImpl(value) {\n    if (value === '*') return value;\n    var arrayAccessor = '';\n    var arrayAccessorMatch = value.match(/(.*?)(\\[[0-9]+\\])/);\n\n    if (arrayAccessorMatch) {\n      value = arrayAccessorMatch[1];\n      arrayAccessor = arrayAccessorMatch[2];\n    }\n\n    return \"\\\"\".concat(value.replace(/\"/g, '\"\"'), \"\\\"\").concat(arrayAccessor);\n  },\n  // Get a raw connection, called by the `pool` whenever a new\n  // connection needs to be added to the pool.\n  acquireRawConnection: function acquireRawConnection() {\n    var client = this;\n    return new _bluebird.default(function (resolver, rejecter) {\n      var connection = new client.driver.Client(client.connectionSettings);\n      connection.connect(function (err, connection) {\n        if (err) {\n          return rejecter(err);\n        }\n\n        connection.on('error', function (err) {\n          connection.__knex__disposed = err;\n        });\n        connection.on('end', function (err) {\n          connection.__knex__disposed = err || 'Connection ended unexpectedly';\n        });\n\n        if (!client.version) {\n          return client.checkVersion(connection).then(function (version) {\n            client.version = version;\n            resolver(connection);\n          });\n        }\n\n        resolver(connection);\n      });\n    }).tap(function setSearchPath(connection) {\n      return client.setSchemaSearchPath(connection);\n    });\n  },\n  // Used to explicitly close a connection, called internally by the pool\n  // when a connection times out or the pool is shutdown.\n  destroyRawConnection: function destroyRawConnection(connection) {\n    return _bluebird.default.fromCallback(connection.end.bind(connection));\n  },\n  // In PostgreSQL, we need to do a version check to do some feature\n  // checking on the database.\n  checkVersion: function checkVersion(connection) {\n    return new _bluebird.default(function (resolver, rejecter) {\n      connection.query('select version();', function (err, resp) {\n        if (err) return rejecter(err);\n        resolver(/^PostgreSQL (.*?)( |$)/.exec(resp.rows[0].version)[1]);\n      });\n    });\n  },\n  // Position the bindings for the query. The escape sequence for question mark\n  // is \\? (e.g. knex.raw(\"\\\\?\") since javascript requires '\\' to be escaped too...)\n  positionBindings: function positionBindings(sql) {\n    var questionCount = 0;\n    return sql.replace(/(\\\\*)(\\?)/g, function (match, escapes) {\n      if (escapes.length % 2) {\n        return '?';\n      } else {\n        questionCount++;\n        return \"$\".concat(questionCount);\n      }\n    });\n  },\n  setSchemaSearchPath: function setSchemaSearchPath(connection, searchPath) {\n    var path = searchPath || this.searchPath;\n    if (!path) return _bluebird.default.resolve(true);\n\n    if (!(0, _lodash.isArray)(path) && !(0, _lodash.isString)(path)) {\n      throw new TypeError(\"knex: Expected searchPath to be Array/String, got: \".concat(typeof path));\n    }\n\n    if ((0, _lodash.isString)(path)) {\n      if ((0, _lodash.includes)(path, ',')) {\n        var parts = path.split(',');\n        var arraySyntax = \"[\".concat((0, _lodash.map)(parts, function (searchPath) {\n          return \"'\".concat(searchPath, \"'\");\n        }).join(', '), \"]\");\n        this.logger.warn(\"Detected comma in searchPath \\\"\".concat(path, \"\\\".\") + \"If you are trying to specify multiple schemas, use Array syntax: \".concat(arraySyntax));\n      }\n\n      path = [path];\n    }\n\n    path = (0, _lodash.map)(path, function (schemaName) {\n      return \"\\\"\".concat(schemaName, \"\\\"\");\n    }).join(',');\n    return new _bluebird.default(function (resolver, rejecter) {\n      connection.query(\"set search_path to \".concat(path), function (err) {\n        if (err) return rejecter(err);\n        resolver(true);\n      });\n    });\n  },\n  _stream: function _stream(connection, obj, stream, options) {\n    var PGQueryStream = process.browser ? undefined : require('pg-query-stream');\n    var sql = obj.sql;\n    return new _bluebird.default(function (resolver, rejecter) {\n      var queryStream = connection.query(new PGQueryStream(sql, obj.bindings, options));\n      queryStream.on('error', function (error) {\n        rejecter(error);\n        stream.emit('error', error);\n      }); // 'end' IS propagated by .pipe, by default\n\n      stream.on('end', resolver);\n      queryStream.pipe(stream);\n    });\n  },\n  // Runs the query on the specified connection, providing the bindings\n  // and any other necessary prep work.\n  _query: function _query(connection, obj) {\n    var sql = obj.sql;\n    if (obj.options) sql = (0, _lodash.extend)({\n      text: sql\n    }, obj.options);\n    return new _bluebird.default(function (resolver, rejecter) {\n      connection.query(sql, obj.bindings, function (err, response) {\n        if (err) return rejecter(err);\n        obj.response = response;\n        resolver(obj);\n      });\n    });\n  },\n  // Ensures the response is returned in the same format as other clients.\n  processResponse: function processResponse(obj, runner) {\n    var resp = obj.response;\n    if (obj.output) return obj.output.call(runner, resp);\n    if (obj.method === 'raw') return resp;\n    var returning = obj.returning;\n\n    if (resp.command === 'SELECT') {\n      if (obj.method === 'first') return resp.rows[0];\n      if (obj.method === 'pluck') return (0, _lodash.map)(resp.rows, obj.pluck);\n      return resp.rows;\n    }\n\n    if (returning) {\n      var returns = [];\n\n      for (var i = 0, l = resp.rows.length; i < l; i++) {\n        var row = resp.rows[i];\n\n        if (returning === '*' || Array.isArray(returning)) {\n          returns[i] = row;\n        } else {\n          // Pluck the only column in the row.\n          returns[i] = row[Object.keys(row)[0]];\n        }\n      }\n\n      return returns;\n    }\n\n    if (resp.command === 'UPDATE' || resp.command === 'DELETE') {\n      return resp.rowCount;\n    }\n\n    return resp;\n  },\n  canCancelQuery: true,\n  cancelQuery: function cancelQuery(connectionToKill) {\n    var _this = this;\n\n    var acquiringConn = this.acquireConnection(); // Error out if we can't acquire connection in time.\n    // Purposely not putting timeout on `pg_terminate_backend` execution because erroring\n    // early there would release the `connectionToKill` back to the pool with\n    // a `KILL QUERY` command yet to finish.\n\n    return acquiringConn.then(function (conn) {\n      return _this._wrappedCancelQueryCall(conn, connectionToKill).finally(function () {\n        // NOT returning this promise because we want to release the connection\n        // in a non-blocking fashion\n        _this.releaseConnection(conn);\n      });\n    });\n  },\n  _wrappedCancelQueryCall: function _wrappedCancelQueryCall(conn, connectionToKill) {\n    return this.query(conn, {\n      method: 'raw',\n      sql: 'SELECT pg_terminate_backend(?);',\n      bindings: [connectionToKill.processID],\n      options: {}\n    });\n  }\n});\n\nfunction arrayString(arr, esc) {\n  var result = '{';\n\n  for (var i = 0; i < arr.length; i++) {\n    if (i > 0) result += ',';\n    var val = arr[i];\n\n    if (val === null || typeof val === 'undefined') {\n      result += 'NULL';\n    } else if (Array.isArray(val)) {\n      result += arrayString(val, esc);\n    } else if (typeof val === 'number') {\n      result += val;\n    } else {\n      result += JSON.stringify(typeof val === 'string' ? val : esc(val));\n    }\n  }\n\n  return result + '}';\n}\n\nvar _default = Client_PG;\nexports.default = _default;\nmodule.exports = exports.default;","map":null,"metadata":{},"sourceType":"script"}