{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _inherits = _interopRequireDefault(require(\"inherits\"));\n\nvar _tablecompiler = _interopRequireDefault(require(\"../../../schema/tablecompiler\"));\n\nvar _lodash = require(\"lodash\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/* eslint max-len: 0 */\n// PostgreSQL Table Builder & Compiler\n// -------\n\n\nfunction TableCompiler_PG() {\n  _tablecompiler.default.apply(this, arguments);\n}\n\n(0, _inherits.default)(TableCompiler_PG, _tablecompiler.default); // Compile a rename column command.\n\nTableCompiler_PG.prototype.renameColumn = function (from, to) {\n  return this.pushQuery({\n    sql: \"alter table \".concat(this.tableName(), \" rename \").concat(this.formatter.wrap(from), \" to \").concat(this.formatter.wrap(to))\n  });\n};\n\nTableCompiler_PG.prototype.compileAdd = function (builder) {\n  var table = this.formatter.wrap(builder);\n  var columns = this.prefixArray('add column', this.getColumns(builder));\n  return this.pushQuery({\n    sql: \"alter table \".concat(table, \" \").concat(columns.join(', '))\n  });\n}; // Adds the \"create\" query to the query sequence.\n\n\nTableCompiler_PG.prototype.createQuery = function (columns, ifNot) {\n  var createStatement = ifNot ? 'create table if not exists ' : 'create table ';\n  var sql = createStatement + this.tableName() + ' (' + columns.sql.join(', ') + ')';\n  if (this.single.inherits) sql += \" inherits (\".concat(this.formatter.wrap(this.single.inherits), \")\");\n  this.pushQuery({\n    sql: sql,\n    bindings: columns.bindings\n  });\n  var hasComment = (0, _lodash.has)(this.single, 'comment');\n  if (hasComment) this.comment(this.single.comment);\n};\n\nTableCompiler_PG.prototype.addColumns = function (columns, prefix, colCompilers) {\n  if (prefix === this.alterColumnsPrefix) {\n    // alter columns\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = colCompilers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var col = _step.value;\n        var quotedTableName = this.tableName();\n        var type = col.getColumnType(); // We'd prefer to call this.formatter.wrapAsIdentifier here instead, however the context passed to\n        // `this` instance is not that of the column, but of the table. Thus, we unfortunately have to call\n        // `wrapIdentifier` here as well (it is already called once on the initial column operation) to give\n        // our `alter` operation the correct `queryContext`. Refer to issue #2606 and PR #2612.\n\n        var colName = this.client.wrapIdentifier(col.getColumnName(), col.columnBuilder.queryContext());\n        this.pushQuery({\n          sql: \"alter table \".concat(quotedTableName, \" alter column \").concat(colName, \" drop default\"),\n          bindings: []\n        });\n        this.pushQuery({\n          sql: \"alter table \".concat(quotedTableName, \" alter column \").concat(colName, \" drop not null\"),\n          bindings: []\n        });\n        this.pushQuery({\n          sql: \"alter table \".concat(quotedTableName, \" alter column \").concat(colName, \" type \").concat(type, \" using (\").concat(colName, \"::\").concat(type, \")\"),\n          bindings: []\n        });\n        var defaultTo = col.modified['defaultTo'];\n\n        if (defaultTo) {\n          var modifier = col.defaultTo.apply(col, defaultTo);\n          this.pushQuery({\n            sql: \"alter table \".concat(quotedTableName, \" alter column \").concat(colName, \" set \").concat(modifier),\n            bindings: []\n          });\n        }\n\n        var nullable = col.modified['nullable'];\n\n        if (nullable && nullable[0] === false) {\n          this.pushQuery({\n            sql: \"alter table \".concat(quotedTableName, \" alter column \").concat(colName, \" set not null\"),\n            bindings: []\n          });\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  } else {\n    // base class implementation for normal add\n    _tablecompiler.default.prototype.addColumns.call(this, columns, prefix);\n  }\n}; // Compiles the comment on the table.\n\n\nTableCompiler_PG.prototype.comment = function (comment) {\n  this.pushQuery(\"comment on table \".concat(this.tableName(), \" is '\").concat(this.single.comment, \"'\"));\n}; // Indexes:\n// -------\n\n\nTableCompiler_PG.prototype.primary = function (columns, constraintName) {\n  constraintName = constraintName ? this.formatter.wrap(constraintName) : this.formatter.wrap(\"\".concat(this.tableNameRaw, \"_pkey\"));\n  this.pushQuery(\"alter table \".concat(this.tableName(), \" add constraint \").concat(constraintName, \" primary key (\").concat(this.formatter.columnize(columns), \")\"));\n};\n\nTableCompiler_PG.prototype.unique = function (columns, indexName) {\n  indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('unique', this.tableNameRaw, columns);\n  this.pushQuery(\"alter table \".concat(this.tableName(), \" add constraint \").concat(indexName) + ' unique (' + this.formatter.columnize(columns) + ')');\n};\n\nTableCompiler_PG.prototype.index = function (columns, indexName, indexType) {\n  indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('index', this.tableNameRaw, columns);\n  this.pushQuery(\"create index \".concat(indexName, \" on \").concat(this.tableName()).concat(indexType && \" using \".concat(indexType) || '') + ' (' + this.formatter.columnize(columns) + ')');\n};\n\nTableCompiler_PG.prototype.dropPrimary = function (constraintName) {\n  constraintName = constraintName ? this.formatter.wrap(constraintName) : this.formatter.wrap(this.tableNameRaw + '_pkey');\n  this.pushQuery(\"alter table \".concat(this.tableName(), \" drop constraint \").concat(constraintName));\n};\n\nTableCompiler_PG.prototype.dropIndex = function (columns, indexName) {\n  indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('index', this.tableNameRaw, columns);\n  indexName = this.schemaNameRaw ? \"\".concat(this.formatter.wrap(this.schemaNameRaw), \".\").concat(indexName) : indexName;\n  this.pushQuery(\"drop index \".concat(indexName));\n};\n\nTableCompiler_PG.prototype.dropUnique = function (columns, indexName) {\n  indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('unique', this.tableNameRaw, columns);\n  this.pushQuery(\"alter table \".concat(this.tableName(), \" drop constraint \").concat(indexName));\n};\n\nTableCompiler_PG.prototype.dropForeign = function (columns, indexName) {\n  indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('foreign', this.tableNameRaw, columns);\n  this.pushQuery(\"alter table \".concat(this.tableName(), \" drop constraint \").concat(indexName));\n};\n\nvar _default = TableCompiler_PG;\nexports.default = _default;\nmodule.exports = exports.default;","map":null,"metadata":{},"sourceType":"script"}