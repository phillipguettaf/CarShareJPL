{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _lodash = require(\"lodash\");\n\nfunction _default(Target) {\n  Target.prototype.toQuery = function (tz) {\n    var _this = this;\n\n    var data = this.toSQL(this._method, tz);\n    if (!(0, _lodash.isArray)(data)) data = [data];\n    return (0, _lodash.map)(data, function (statement) {\n      return _this.client._formatQuery(statement.sql, statement.bindings, tz);\n    }).join(';\\n');\n  }; // Create a new instance of the `Runner`, passing in the current object.\n\n\n  Target.prototype.then = function ()\n  /* onFulfilled, onRejected */\n  {\n    var _this2 = this;\n\n    var result = this.client.runner(this).run();\n\n    if (this.client.config.asyncStackTraces) {\n      result = result.catch(function (err) {\n        err.originalStack = err.stack;\n        var firstLine = err.stack.split('\\n')[0];\n\n        _this2._asyncStack.unshift(firstLine); // put the fake more helpful \"async\" stack on the thrown error\n\n\n        err.stack = _this2._asyncStack.join('\\n');\n        throw err;\n      });\n    }\n\n    return result.then.apply(result, arguments);\n  }; // Add additional \"options\" to the builder. Typically used for client specific\n  // items, like the `mysql` and `sqlite3` drivers.\n\n\n  Target.prototype.options = function (opts) {\n    this._options = this._options || [];\n\n    this._options.push((0, _lodash.clone)(opts) || {});\n\n    return this;\n  }; // Sets an explicit \"connection\" we wish to use for this query.\n\n\n  Target.prototype.connection = function (connection) {\n    this._connection = connection;\n    return this;\n  }; // Set a debug flag for the current schema query stack.\n\n\n  Target.prototype.debug = function (enabled) {\n    this._debug = arguments.length ? enabled : true;\n    return this;\n  }; // Set the transaction object for this query.\n\n\n  Target.prototype.transacting = function (t) {\n    if (t && t.client) {\n      if (!t.client.transacting) {\n        t.client.logger.warn(\"Invalid transaction value: \".concat(t.client));\n      } else {\n        this.client = t.client;\n      }\n    }\n\n    if ((0, _lodash.isEmpty)(t)) {\n      this.client.logger.error('Invalid value on transacting call, potential bug');\n      throw Error('Invalid transacting value (null, undefined or empty object)');\n    }\n\n    return this;\n  }; // Initializes a stream.\n\n\n  Target.prototype.stream = function (options) {\n    return this.client.runner(this).stream(options);\n  }; // Initialize a stream & pipe automatically.\n\n\n  Target.prototype.pipe = function (writable, options) {\n    return this.client.runner(this).pipe(writable, options);\n  }; // Creates a method which \"coerces\" to a promise, by calling a\n  // \"then\" method on the current `Target`\n\n\n  (0, _lodash.each)(['bind', 'catch', 'finally', 'asCallback', 'spread', 'map', 'reduce', 'tap', 'thenReturn', 'return', 'yield', 'ensure', 'reflect', 'get', 'mapSeries', 'delay'], function (method) {\n    Target.prototype[method] = function () {\n      var promise = this.then();\n      return promise[method].apply(promise, arguments);\n    };\n  });\n}\n\nmodule.exports = exports.default;","map":null,"metadata":{},"sourceType":"script"}