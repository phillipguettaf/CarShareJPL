{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = makeKnex;\n\nvar _events = require(\"events\");\n\nvar _Migrator = _interopRequireDefault(require(\"../migrate/Migrator\"));\n\nvar _seed = _interopRequireDefault(require(\"../seed\"));\n\nvar _functionhelper = _interopRequireDefault(require(\"../functionhelper\"));\n\nvar _methods = _interopRequireDefault(require(\"../query/methods\"));\n\nvar _lodash = require(\"lodash\");\n\nvar _batchInsert = _interopRequireDefault(require(\"./batchInsert\"));\n\nvar bluebird = _interopRequireWildcard(require(\"bluebird\"));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction makeKnex(client) {\n  // The object we're potentially using to kick off an initial chain.\n  function knex(tableName, options) {\n    return createQueryBuilder(knex.context, tableName, options);\n  }\n\n  redefineProperties(knex, client);\n  return knex;\n}\n\nfunction initContext(knexFn) {\n  var knexContext = knexFn.context || {};\n  (0, _lodash.assign)(knexContext, {\n    queryBuilder: function queryBuilder() {\n      return this.client.queryBuilder();\n    },\n    raw: function raw() {\n      return this.client.raw.apply(this.client, arguments);\n    },\n    batchInsert: function batchInsert(table, batch) {\n      var chunkSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;\n      return (0, _batchInsert.default)(this, table, batch, chunkSize);\n    },\n    // Runs a new transaction, taking a container and returning a promise\n    // for when the transaction is resolved.\n    transaction: function transaction(container, config) {\n      var trx = this.client.transaction(container, config);\n      trx.userParams = this.userParams;\n      return trx;\n    },\n    // Typically never needed, initializes the pool for a knex client.\n    initialize: function initialize(config) {\n      return this.client.initializePool(config);\n    },\n    // Convenience method for tearing down the pool.\n    destroy: function destroy(callback) {\n      return this.client.destroy(callback);\n    },\n    ref: function ref(_ref) {\n      return this.client.ref(_ref);\n    },\n    // Do not document this as public API until naming and API is improved for general consumption\n    // This method exists to disable processing of internal queries in migrations\n    disableProcessing: function disableProcessing() {\n      if (this.userParams.isProcessingDisabled) {\n        return;\n      }\n\n      this.userParams.wrapIdentifier = this.client.config.wrapIdentifier;\n      this.userParams.postProcessResponse = this.client.config.postProcessResponse;\n      this.client.config.wrapIdentifier = null;\n      this.client.config.postProcessResponse = null;\n      this.userParams.isProcessingDisabled = true;\n    },\n    // Do not document this as public API until naming and API is improved for general consumption\n    // This method exists to enable execution of non-internal queries with consistent identifier naming in migrations\n    enableProcessing: function enableProcessing() {\n      if (!this.userParams.isProcessingDisabled) {\n        return;\n      }\n\n      this.client.config.wrapIdentifier = this.userParams.wrapIdentifier;\n      this.client.config.postProcessResponse = this.userParams.postProcessResponse;\n      this.userParams.isProcessingDisabled = false;\n    },\n    withUserParams: function withUserParams(params) {\n      var knexClone = shallowCloneFunction(knexFn); // We need to include getters in our clone\n\n      if (this.client) {\n        knexClone.client = Object.assign({}, this.client); // Clone client to avoid leaking listeners that are set on it\n\n        knexClone.client.config = Object.assign({}, this.client.config); // Clone client config to make sure they can be modified independently\n\n        var parentPrototype = Object.getPrototypeOf(this.client);\n\n        if (parentPrototype) {\n          Object.setPrototypeOf(knexClone.client, parentPrototype);\n        }\n      }\n\n      redefineProperties(knexClone, knexClone.client);\n      knexClone.userParams = params;\n      return knexClone;\n    }\n  });\n\n  if (!knexFn.context) {\n    knexFn.context = knexContext;\n  }\n}\n\nfunction redefineProperties(knex, client) {\n  // Allow chaining methods from the root object, before\n  // any other information is specified.\n  _methods.default.forEach(function (method) {\n    knex[method] = function () {\n      var builder = knex.queryBuilder();\n      return builder[method].apply(builder, arguments);\n    };\n  });\n\n  Object.defineProperties(knex, {\n    context: {\n      get: function get() {\n        return knex._context;\n      },\n      set: function set(context) {\n        knex._context = context; // Redefine public API for knex instance that would be proxying methods from correct context\n\n        knex.raw = context.raw;\n        knex.batchInsert = context.batchInsert;\n        knex.transaction = context.transaction;\n        knex.initialize = context.initialize;\n        knex.destroy = context.destroy;\n        knex.ref = context.ref;\n        knex.withUserParams = context.withUserParams;\n        knex.queryBuilder = context.queryBuilder;\n        knex.disableProcessing = context.disableProcessing;\n        knex.enableProcessing = context.enableProcessing;\n      },\n      configurable: true\n    },\n    client: {\n      get: function get() {\n        return knex.context.client;\n      },\n      set: function set(client) {\n        knex.context.client = client;\n      },\n      configurable: true\n    },\n    userParams: {\n      get: function get() {\n        return knex.context.userParams;\n      },\n      set: function set(userParams) {\n        knex.context.userParams = userParams;\n      },\n      configurable: true\n    },\n    schema: {\n      get: function get() {\n        return knex.client.schemaBuilder();\n      },\n      configurable: true\n    },\n    migrate: {\n      get: function get() {\n        return new _Migrator.default(knex);\n      },\n      configurable: true\n    },\n    seed: {\n      get: function get() {\n        return new _seed.default(knex);\n      },\n      configurable: true\n    },\n    fn: {\n      get: function get() {\n        return new _functionhelper.default(knex.client);\n      },\n      configurable: true\n    }\n  });\n  initContext(knex);\n  knex.Promise = bluebird;\n  knex.client = client;\n  knex.client.makeKnex = makeKnex;\n  knex.userParams = {}; // Hook up the \"knex\" object as an EventEmitter.\n\n  var ee = new _events.EventEmitter();\n\n  for (var key in ee) {\n    knex[key] = ee[key];\n  } // Passthrough all \"start\" and \"query\" events to the knex object.\n\n\n  knex.client.on('start', function (obj) {\n    knex.emit('start', obj);\n  });\n  knex.client.on('query', function (obj) {\n    knex.emit('query', obj);\n  });\n  knex.client.on('query-error', function (err, obj) {\n    knex.emit('query-error', err, obj);\n  });\n  knex.client.on('query-response', function (response, obj, builder) {\n    knex.emit('query-response', response, obj, builder);\n  });\n}\n\nfunction createQueryBuilder(knexContext, tableName, options) {\n  var qb = knexContext.queryBuilder();\n  if (!tableName) knexContext.client.logger.warn('calling knex without a tableName is deprecated. Use knex.queryBuilder() instead.');\n  return tableName ? qb.table(tableName, options) : qb;\n}\n\nfunction shallowCloneFunction(originalFunction) {\n  var fnContext = Object.create(Object.getPrototypeOf(originalFunction), Object.getOwnPropertyDescriptors(originalFunction));\n  var knexContext = {};\n\n  var knexFnWrapper = function knexFnWrapper(tableName, options) {\n    return createQueryBuilder(knexContext, tableName, options);\n  };\n\n  var clonedFunction = knexFnWrapper.bind(fnContext);\n  Object.assign(clonedFunction, originalFunction);\n  clonedFunction._context = knexContext;\n  return clonedFunction;\n}\n\nmodule.exports = exports.default;","map":null,"metadata":{},"sourceType":"script"}