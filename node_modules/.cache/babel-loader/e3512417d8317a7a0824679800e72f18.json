{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar helpers = _interopRequireWildcard(require(\"../helpers\"));\n\nvar _raw = _interopRequireDefault(require(\"../raw\"));\n\nvar _joinclause = _interopRequireDefault(require(\"./joinclause\"));\n\nvar _debug = _interopRequireDefault(require(\"debug\"));\n\nvar _lodash = require(\"lodash\");\n\nvar _uuid = _interopRequireDefault(require(\"uuid\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n} // Query Compiler\n// -------\n\n\nvar debugBindings = (0, _debug.default)('knex:bindings'); // The \"QueryCompiler\" takes all of the query statements which\n// have been gathered in the \"QueryBuilder\" and turns them into a\n// properly formatted / bound query string.\n\nfunction QueryCompiler(client, builder) {\n  this.client = client;\n  this.method = builder._method || 'select';\n  this.options = builder._options;\n  this.single = builder._single;\n  this.timeout = builder._timeout || false;\n  this.cancelOnTimeout = builder._cancelOnTimeout || false;\n  this.grouped = (0, _lodash.groupBy)(builder._statements, 'grouping');\n  this.formatter = client.formatter(builder);\n}\n\nvar components = ['columns', 'join', 'where', 'union', 'group', 'having', 'order', 'limit', 'offset', 'lock'];\n(0, _lodash.assign)(QueryCompiler.prototype, {\n  // Used when the insert call is empty.\n  _emptyInsertValue: 'default values',\n  // Collapse the builder into a single object\n  toSQL: function toSQL(method, tz) {\n    var _this = this;\n\n    this._undefinedInWhereClause = false;\n    method = method || this.method;\n    var val = this[method]() || '';\n    var query = {\n      method: method,\n      options: (0, _lodash.reduce)(this.options, _lodash.assign, {}),\n      timeout: this.timeout,\n      cancelOnTimeout: this.cancelOnTimeout,\n      bindings: this.formatter.bindings || [],\n      __knexQueryUid: _uuid.default.v4()\n    };\n    Object.defineProperties(query, {\n      toNative: {\n        value: function value() {\n          return {\n            sql: _this.client.positionBindings(query.sql),\n            bindings: _this.client.prepBindings(query.bindings)\n          };\n        },\n        enumerable: false\n      }\n    });\n\n    if ((0, _lodash.isString)(val)) {\n      query.sql = val;\n    } else {\n      (0, _lodash.assign)(query, val);\n    }\n\n    if (method === 'select' || method === 'first') {\n      if (this.single.as) {\n        query.as = this.single.as;\n      }\n    }\n\n    if (this._undefinedInWhereClause) {\n      debugBindings(query.bindings);\n      throw new Error(\"Undefined binding(s) detected when compiling \" + \"\".concat(method.toUpperCase(), \" query: \").concat(query.sql));\n    }\n\n    return query;\n  },\n  // Compiles the `select` statement, or nested sub-selects by calling each of\n  // the component compilers, trimming out the empties, and returning a\n  // generated query string.\n  select: function select() {\n    var _this2 = this;\n\n    var sql = this.with();\n    var statements = components.map(function (component) {\n      return _this2[component](_this2);\n    });\n    sql += (0, _lodash.compact)(statements).join(' ');\n    return sql;\n  },\n  pluck: function pluck() {\n    var toPluck = this.single.pluck;\n\n    if (toPluck.indexOf('.') !== -1) {\n      toPluck = toPluck.split('.').slice(-1)[0];\n    }\n\n    return {\n      sql: this.select(),\n      pluck: toPluck\n    };\n  },\n  // Compiles an \"insert\" query, allowing for multiple\n  // inserts using a single query statement.\n  insert: function insert() {\n    var insertValues = this.single.insert || [];\n    var sql = this.with() + \"insert into \".concat(this.tableName, \" \");\n\n    if (Array.isArray(insertValues)) {\n      if (insertValues.length === 0) {\n        return '';\n      }\n    } else if (typeof insertValues === 'object' && (0, _lodash.isEmpty)(insertValues)) {\n      return sql + this._emptyInsertValue;\n    }\n\n    var insertData = this._prepInsert(insertValues);\n\n    if (typeof insertData === 'string') {\n      sql += insertData;\n    } else {\n      if (insertData.columns.length) {\n        sql += \"(\".concat(this.formatter.columnize(insertData.columns));\n        sql += ') values (';\n        var i = -1;\n\n        while (++i < insertData.values.length) {\n          if (i !== 0) sql += '), (';\n          sql += this.formatter.parameterize(insertData.values[i], this.client.valueForUndefined);\n        }\n\n        sql += ')';\n      } else if (insertValues.length === 1 && insertValues[0]) {\n        sql += this._emptyInsertValue;\n      } else {\n        sql = '';\n      }\n    }\n\n    return sql;\n  },\n  // Compiles the \"update\" query.\n  update: function update() {\n    // Make sure tableName is processed by the formatter first.\n    var withSQL = this.with();\n    var tableName = this.tableName;\n\n    var updateData = this._prepUpdate(this.single.update);\n\n    var wheres = this.where();\n    return withSQL + \"update \".concat(this.single.only ? 'only ' : '').concat(tableName) + ' set ' + updateData.join(', ') + (wheres ? \" \".concat(wheres) : '');\n  },\n  // Compiles the columns in the query, specifying if an item was distinct.\n  columns: function columns() {\n    var distinct = false;\n    if (this.onlyUnions()) return '';\n    var columns = this.grouped.columns || [];\n    var i = -1,\n        sql = [];\n\n    if (columns) {\n      while (++i < columns.length) {\n        var stmt = columns[i];\n        if (stmt.distinct) distinct = true;\n\n        if (stmt.type === 'aggregate') {\n          sql.push(this.aggregate(stmt));\n        } else if (stmt.type === 'aggregateRaw') {\n          sql.push(this.aggregateRaw(stmt));\n        } else if (stmt.value && stmt.value.length > 0) {\n          sql.push(this.formatter.columnize(stmt.value));\n        }\n      }\n    }\n\n    if (sql.length === 0) sql = ['*'];\n    return \"select \".concat(distinct ? 'distinct ' : '') + sql.join(', ') + (this.tableName ? \" from \".concat(this.single.only ? 'only ' : '').concat(this.tableName) : '');\n  },\n  _aggregate: function _aggregate(stmt) {\n    var _this3 = this;\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$aliasSeparator = _ref.aliasSeparator,\n        aliasSeparator = _ref$aliasSeparator === void 0 ? ' as ' : _ref$aliasSeparator,\n        distinctParentheses = _ref.distinctParentheses;\n\n    var value = stmt.value;\n    var method = stmt.method;\n    var distinct = stmt.aggregateDistinct ? 'distinct ' : '';\n\n    var wrap = function wrap(identifier) {\n      return _this3.formatter.wrap(identifier);\n    };\n\n    var addAlias = function addAlias(value, alias) {\n      if (alias) {\n        return value + aliasSeparator + wrap(alias);\n      }\n\n      return value;\n    };\n\n    var aggregateArray = function aggregateArray(value, alias) {\n      var columns = value.map(wrap).join(', ');\n\n      if (distinct) {\n        var openParen = distinctParentheses ? '(' : ' ';\n        var closeParen = distinctParentheses ? ')' : '';\n        columns = distinct.trim() + openParen + columns + closeParen;\n      }\n\n      var aggregated = \"\".concat(method, \"(\").concat(columns, \")\");\n      return addAlias(aggregated, alias);\n    };\n\n    var aggregateString = function aggregateString(value, alias) {\n      var aggregated = \"\".concat(method, \"(\").concat(distinct + wrap(value), \")\");\n      return addAlias(aggregated, alias);\n    };\n\n    if (Array.isArray(value)) {\n      return aggregateArray(value);\n    }\n\n    if (typeof value === 'object') {\n      var keys = Object.keys(value);\n      var alias = keys[0];\n      var column = value[alias];\n\n      if (Array.isArray(column)) {\n        return aggregateArray(column, alias);\n      }\n\n      return aggregateString(column, alias);\n    } // Allows us to speciy an alias for the aggregate types.\n\n\n    var splitOn = value.toLowerCase().indexOf(' as ');\n\n    if (splitOn !== -1) {\n      var _column = value.slice(0, splitOn);\n\n      var _alias = value.slice(splitOn + 4);\n\n      return aggregateString(_column, _alias);\n    }\n\n    return aggregateString(value);\n  },\n  aggregate: function aggregate(stmt) {\n    return this._aggregate(stmt);\n  },\n  aggregateRaw: function aggregateRaw(stmt) {\n    var distinct = stmt.aggregateDistinct ? 'distinct ' : '';\n    return \"\".concat(stmt.method, \"(\").concat(distinct + this.formatter.unwrapRaw(stmt.value), \")\");\n  },\n  // Compiles all each of the `join` clauses on the query,\n  // including any nested join queries.\n  join: function join() {\n    var sql = '';\n    var i = -1;\n    var joins = this.grouped.join;\n    if (!joins) return '';\n\n    while (++i < joins.length) {\n      var join = joins[i];\n      var table = join.schema ? \"\".concat(join.schema, \".\").concat(join.table) : join.table;\n      if (i > 0) sql += ' ';\n\n      if (join.joinType === 'raw') {\n        sql += this.formatter.unwrapRaw(join.table);\n      } else {\n        sql += join.joinType + ' join ' + this.formatter.wrap(table);\n        var ii = -1;\n\n        while (++ii < join.clauses.length) {\n          var clause = join.clauses[ii];\n\n          if (ii > 0) {\n            sql += \" \".concat(clause.bool, \" \");\n          } else {\n            sql += \" \".concat(clause.type === 'onUsing' ? 'using' : 'on', \" \");\n          }\n\n          var val = this[clause.type].call(this, clause);\n\n          if (val) {\n            sql += val;\n          }\n        }\n      }\n    }\n\n    return sql;\n  },\n  onBetween: function onBetween(statement) {\n    return this.formatter.wrap(statement.column) + ' ' + this._not(statement, 'between') + ' ' + (0, _lodash.map)(statement.value, (0, _lodash.bind)(this.formatter.parameter, this.formatter)).join(' and ');\n  },\n  onNull: function onNull(statement) {\n    return this.formatter.wrap(statement.column) + ' is ' + this._not(statement, 'null');\n  },\n  onExists: function onExists(statement) {\n    return this._not(statement, 'exists') + ' (' + this.formatter.rawOrFn(statement.value) + ')';\n  },\n  onIn: function onIn(statement) {\n    if (Array.isArray(statement.column)) return this.multiOnIn(statement);\n    return this.formatter.wrap(statement.column) + ' ' + this._not(statement, 'in ') + this.wrap(this.formatter.parameterize(statement.value));\n  },\n  multiOnIn: function multiOnIn(statement) {\n    var i = -1,\n        sql = \"(\".concat(this.formatter.columnize(statement.column), \") \");\n    sql += this._not(statement, 'in ') + '((';\n\n    while (++i < statement.value.length) {\n      if (i !== 0) sql += '),(';\n      sql += this.formatter.parameterize(statement.value[i]);\n    }\n\n    return sql + '))';\n  },\n  // Compiles all `where` statements on the query.\n  where: function where() {\n    var wheres = this.grouped.where;\n    if (!wheres) return;\n    var sql = [];\n    var i = -1;\n\n    while (++i < wheres.length) {\n      var stmt = wheres[i];\n\n      if (stmt.hasOwnProperty('value') && helpers.containsUndefined(stmt.value)) {\n        this._undefinedInWhereClause = true;\n      }\n\n      var val = this[stmt.type](stmt);\n\n      if (val) {\n        if (sql.length === 0) {\n          sql[0] = 'where';\n        } else {\n          sql.push(stmt.bool);\n        }\n\n        sql.push(val);\n      }\n    }\n\n    return sql.length > 1 ? sql.join(' ') : '';\n  },\n  group: function group() {\n    return this._groupsOrders('group');\n  },\n  order: function order() {\n    return this._groupsOrders('order');\n  },\n  // Compiles the `having` statements.\n  having: function having() {\n    var havings = this.grouped.having;\n    if (!havings) return '';\n    var sql = ['having'];\n\n    for (var i = 0, l = havings.length; i < l; i++) {\n      var s = havings[i];\n      var val = this[s.type](s);\n\n      if (val) {\n        if (sql.length === 0) {\n          sql[0] = 'where';\n        }\n\n        if (sql.length > 1 || sql.length === 1 && sql[0] !== 'having') {\n          sql.push(s.bool);\n        }\n\n        sql.push(val);\n      }\n    }\n\n    return sql.length > 1 ? sql.join(' ') : '';\n  },\n  havingRaw: function havingRaw(statement) {\n    return this._not(statement, '') + this.formatter.unwrapRaw(statement.value);\n  },\n  havingWrapped: function havingWrapped(statement) {\n    var val = this.formatter.rawOrFn(statement.value, 'where');\n    return val && this._not(statement, '') + '(' + val.slice(6) + ')' || '';\n  },\n  havingBasic: function havingBasic(statement) {\n    return this._not(statement, '') + this.formatter.wrap(statement.column) + ' ' + this.formatter.operator(statement.operator) + ' ' + this.formatter.parameter(statement.value);\n  },\n  havingNull: function havingNull(statement) {\n    return this.formatter.wrap(statement.column) + ' is ' + this._not(statement, 'null');\n  },\n  havingExists: function havingExists(statement) {\n    return this._not(statement, 'exists') + ' (' + this.formatter.rawOrFn(statement.value) + ')';\n  },\n  havingBetween: function havingBetween(statement) {\n    return this.formatter.wrap(statement.column) + ' ' + this._not(statement, 'between') + ' ' + (0, _lodash.map)(statement.value, (0, _lodash.bind)(this.formatter.parameter, this.formatter)).join(' and ');\n  },\n  havingIn: function havingIn(statement) {\n    if (Array.isArray(statement.column)) return this.multiHavingIn(statement);\n    return this.formatter.wrap(statement.column) + ' ' + this._not(statement, 'in ') + this.wrap(this.formatter.parameterize(statement.value));\n  },\n  multiHavingIn: function multiHavingIn(statement) {\n    var i = -1,\n        sql = \"(\".concat(this.formatter.columnize(statement.column), \") \");\n    sql += this._not(statement, 'in ') + '((';\n\n    while (++i < statement.value.length) {\n      if (i !== 0) sql += '),(';\n      sql += this.formatter.parameterize(statement.value[i]);\n    }\n\n    return sql + '))';\n  },\n  // Compile the \"union\" queries attached to the main query.\n  union: function union() {\n    var onlyUnions = this.onlyUnions();\n    var unions = this.grouped.union;\n    if (!unions) return '';\n    var sql = '';\n\n    for (var i = 0, l = unions.length; i < l; i++) {\n      var union = unions[i];\n      if (i > 0) sql += ' ';\n      if (i > 0 || !onlyUnions) sql += union.clause + ' ';\n      var statement = this.formatter.rawOrFn(union.value);\n\n      if (statement) {\n        if (union.wrap) sql += '(';\n        sql += statement;\n        if (union.wrap) sql += ')';\n      }\n    }\n\n    return sql;\n  },\n  // If we haven't specified any columns or a `tableName`, we're assuming this\n  // is only being used for unions.\n  onlyUnions: function onlyUnions() {\n    return !this.grouped.columns && this.grouped.union && !this.tableName;\n  },\n  limit: function limit() {\n    var noLimit = !this.single.limit && this.single.limit !== 0;\n    if (noLimit) return '';\n    return \"limit \".concat(this.formatter.parameter(this.single.limit));\n  },\n  offset: function offset() {\n    if (!this.single.offset) return '';\n    return \"offset \".concat(this.formatter.parameter(this.single.offset));\n  },\n  // Compiles a `delete` query.\n  del: function del() {\n    // Make sure tableName is processed by the formatter first.\n    var tableName = this.tableName;\n    var withSQL = this.with();\n    var wheres = this.where();\n    return withSQL + \"delete from \".concat(this.single.only ? 'only ' : '').concat(tableName) + (wheres ? \" \".concat(wheres) : '');\n  },\n  // Compiles a `truncate` query.\n  truncate: function truncate() {\n    return \"truncate \".concat(this.tableName);\n  },\n  // Compiles the \"locks\".\n  lock: function lock() {\n    if (this.single.lock) {\n      return this[this.single.lock]();\n    }\n  },\n  // On Clause\n  // ------\n  onWrapped: function onWrapped(clause) {\n    var self = this;\n    var wrapJoin = new _joinclause.default();\n    clause.value.call(wrapJoin, wrapJoin);\n    var sql = '';\n    wrapJoin.clauses.forEach(function (wrapClause, ii) {\n      if (ii > 0) {\n        sql += \" \".concat(wrapClause.bool, \" \");\n      }\n\n      var val = self[wrapClause.type](wrapClause);\n\n      if (val) {\n        sql += val;\n      }\n    });\n\n    if (sql.length) {\n      return \"(\".concat(sql, \")\");\n    }\n\n    return '';\n  },\n  onBasic: function onBasic(clause) {\n    return this.formatter.wrap(clause.column) + ' ' + this.formatter.operator(clause.operator) + ' ' + this.formatter.wrap(clause.value);\n  },\n  onVal: function onVal(clause) {\n    return this.formatter.wrap(clause.column) + ' ' + this.formatter.operator(clause.operator) + ' ' + this.formatter.parameter(clause.value);\n  },\n  onRaw: function onRaw(clause) {\n    return this.formatter.unwrapRaw(clause.value);\n  },\n  onUsing: function onUsing(clause) {\n    return '(' + this.formatter.columnize(clause.column) + ')';\n  },\n  // Where Clause\n  // ------\n  whereIn: function whereIn(statement) {\n    var columns = null;\n\n    if (Array.isArray(statement.column)) {\n      columns = \"(\".concat(this.formatter.columnize(statement.column), \")\");\n    } else {\n      columns = this.formatter.wrap(statement.column);\n    }\n\n    var values = this.formatter.values(statement.value);\n    return \"\".concat(columns, \" \").concat(this._not(statement, 'in ')).concat(values);\n  },\n  whereNull: function whereNull(statement) {\n    return this.formatter.wrap(statement.column) + ' is ' + this._not(statement, 'null');\n  },\n  // Compiles a basic \"where\" clause.\n  whereBasic: function whereBasic(statement) {\n    return this._not(statement, '') + this.formatter.wrap(statement.column) + ' ' + this.formatter.operator(statement.operator) + ' ' + (statement.asColumn ? this.formatter.wrap(statement.value) : this.formatter.parameter(statement.value));\n  },\n  whereExists: function whereExists(statement) {\n    return this._not(statement, 'exists') + ' (' + this.formatter.rawOrFn(statement.value) + ')';\n  },\n  whereWrapped: function whereWrapped(statement) {\n    var val = this.formatter.rawOrFn(statement.value, 'where');\n    return val && this._not(statement, '') + '(' + val.slice(6) + ')' || '';\n  },\n  whereBetween: function whereBetween(statement) {\n    return this.formatter.wrap(statement.column) + ' ' + this._not(statement, 'between') + ' ' + (0, _lodash.map)(statement.value, (0, _lodash.bind)(this.formatter.parameter, this.formatter)).join(' and ');\n  },\n  // Compiles a \"whereRaw\" query.\n  whereRaw: function whereRaw(statement) {\n    return this._not(statement, '') + this.formatter.unwrapRaw(statement.value);\n  },\n  wrap: function wrap(str) {\n    if (str.charAt(0) !== '(') return \"(\".concat(str, \")\");\n    return str;\n  },\n  // Compiles all `with` statements on the query.\n  with: function _with() {\n    if (!this.grouped.with || !this.grouped.with.length) {\n      return '';\n    }\n\n    var withs = this.grouped.with;\n    if (!withs) return;\n    var sql = [];\n    var i = -1;\n    var isRecursive = false;\n\n    while (++i < withs.length) {\n      var stmt = withs[i];\n\n      if (stmt.recursive) {\n        isRecursive = true;\n      }\n\n      var val = this[stmt.type](stmt);\n      sql.push(val);\n    }\n\n    return \"with \".concat(isRecursive ? 'recursive ' : '').concat(sql.join(', '), \" \");\n  },\n  withWrapped: function withWrapped(statement) {\n    var val = this.formatter.rawOrFn(statement.value);\n    return val && this.formatter.columnize(statement.alias) + ' as (' + val + ')' || '';\n  },\n  // Determines whether to add a \"not\" prefix to the where clause.\n  _not: function _not(statement, str) {\n    if (statement.not) return \"not \".concat(str);\n    return str;\n  },\n  _prepInsert: function _prepInsert(data) {\n    var isRaw = this.formatter.rawOrFn(data);\n    if (isRaw) return isRaw;\n    var columns = [];\n    var values = [];\n    if (!Array.isArray(data)) data = data ? [data] : [];\n    var i = -1;\n\n    while (++i < data.length) {\n      if (data[i] == null) break;\n      if (i === 0) columns = Object.keys(data[i]).sort();\n      var row = new Array(columns.length);\n      var keys = Object.keys(data[i]);\n      var j = -1;\n\n      while (++j < keys.length) {\n        var key = keys[j];\n        var idx = columns.indexOf(key);\n\n        if (idx === -1) {\n          columns = columns.concat(key).sort();\n          idx = columns.indexOf(key);\n          var k = -1;\n\n          while (++k < values.length) {\n            values[k].splice(idx, 0, undefined);\n          }\n\n          row.splice(idx, 0, undefined);\n        }\n\n        row[idx] = data[i][key];\n      }\n\n      values.push(row);\n    }\n\n    return {\n      columns: columns,\n      values: values\n    };\n  },\n  // \"Preps\" the update.\n  _prepUpdate: function _prepUpdate() {\n    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var _this$single$counter = this.single.counter,\n        counter = _this$single$counter === void 0 ? {} : _this$single$counter;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = (0, _lodash.keys)(counter)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var column = _step.value; //Skip?\n\n        if ((0, _lodash.has)(data, column)) {\n          //Needed?\n          this.client.logger.warn(\"increment/decrement called for a column that has already been specified in main .update() call. Ignoring increment/decrement and using value from .update() call.\");\n          continue;\n        }\n\n        var value = counter[column];\n        var symbol = value < 0 ? '-' : '+';\n\n        if (symbol === '-') {\n          value = -value;\n        }\n\n        data[column] = this.client.raw(\"?? \".concat(symbol, \" ?\"), [column, value]);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    data = (0, _lodash.omitBy)(data, _lodash.isUndefined);\n    var vals = [];\n    var columns = Object.keys(data);\n    var i = -1;\n\n    while (++i < columns.length) {\n      vals.push(this.formatter.wrap(columns[i]) + ' = ' + this.formatter.parameter(data[columns[i]]));\n    }\n\n    if ((0, _lodash.isEmpty)(vals)) {\n      throw new Error(['Empty .update() call detected!', 'Update data does not contain any values to update.', 'This will result in a faulty query.'].join(' '));\n    }\n\n    return vals;\n  },\n  // Compiles the `order by` statements.\n  _groupsOrders: function _groupsOrders(type) {\n    var items = this.grouped[type];\n    if (!items) return '';\n    var formatter = this.formatter;\n    var sql = items.map(function (item) {\n      var column = item.value instanceof _raw.default ? formatter.unwrapRaw(item.value) : formatter.columnize(item.value);\n      var direction = type === 'order' && item.type !== 'orderByRaw' ? \" \".concat(formatter.direction(item.direction)) : '';\n      return column + direction;\n    });\n    return sql.length ? type + ' by ' + sql.join(', ') : '';\n  }\n});\nQueryCompiler.prototype.first = QueryCompiler.prototype.select; // Get the table name, wrapping it if necessary.\n// Implemented as a property to prevent ordering issues as described in #704.\n\nObject.defineProperty(QueryCompiler.prototype, 'tableName', {\n  get: function get() {\n    if (!this._tableName) {\n      // Only call this.formatter.wrap() the first time this property is accessed.\n      var tableName = this.single.table;\n      var schemaName = this.single.schema;\n      if (tableName && schemaName) tableName = \"\".concat(schemaName, \".\").concat(tableName);\n      this._tableName = tableName ? this.formatter.wrap(tableName) : '';\n    }\n\n    return this._tableName;\n  }\n});\nvar _default = QueryCompiler;\nexports.default = _default;\nmodule.exports = exports.default;","map":null,"metadata":{},"sourceType":"script"}