{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _bluebird = _interopRequireDefault(require(\"bluebird\"));\n\nvar _lodash = require(\"lodash\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // SQLite3_DDL\n//\n// All of the SQLite3 specific DDL helpers for renaming/dropping\n// columns and changing datatypes.\n// -------\n// So altering the schema in SQLite3 is a major pain.\n// We have our own object to deal with the renaming and altering the types\n// for sqlite3 things.\n\n\nfunction SQLite3_DDL(client, tableCompiler, pragma, connection) {\n  this.client = client;\n  this.tableCompiler = tableCompiler;\n  this.pragma = pragma;\n  this.tableName = this.tableCompiler.tableNameRaw;\n  this.alteredName = (0, _lodash.uniqueId)('_knex_temp_alter');\n  this.connection = connection;\n}\n\n(0, _lodash.assign)(SQLite3_DDL.prototype, {\n  getColumn: _bluebird.default.method(function (column) {\n    var currentCol = (0, _lodash.find)(this.pragma, {\n      name: column\n    });\n    if (!currentCol) throw new Error(\"The column \".concat(column, \" is not in the \").concat(this.tableName, \" table\"));\n    return currentCol;\n  }),\n  getTableSql: function getTableSql() {\n    return this.trx.raw(\"SELECT name, sql FROM sqlite_master WHERE type=\\\"table\\\" AND name=\\\"\".concat(this.tableName, \"\\\"\"));\n  },\n  renameTable: _bluebird.default.method(function () {\n    return this.trx.raw(\"ALTER TABLE \\\"\".concat(this.tableName, \"\\\" RENAME TO \\\"\").concat(this.alteredName, \"\\\"\"));\n  }),\n  dropOriginal: function dropOriginal() {\n    return this.trx.raw(\"DROP TABLE \\\"\".concat(this.tableName, \"\\\"\"));\n  },\n  dropTempTable: function dropTempTable() {\n    return this.trx.raw(\"DROP TABLE \\\"\".concat(this.alteredName, \"\\\"\"));\n  },\n  copyData: function copyData() {\n    return this.trx.raw(\"SELECT * FROM \\\"\".concat(this.tableName, \"\\\"\")).bind(this).then(this.insertChunked(20, this.alteredName));\n  },\n  reinsertData: function reinsertData(iterator) {\n    return function () {\n      return this.trx.raw(\"SELECT * FROM \\\"\".concat(this.alteredName, \"\\\"\")).bind(this).then(this.insertChunked(20, this.tableName, iterator));\n    };\n  },\n  insertChunked: function insertChunked(amount, target, iterator) {\n    iterator = iterator || _lodash.identity;\n    return function (result) {\n      var batch = [];\n      var ddl = this;\n      return _bluebird.default.reduce(result, function (memo, row) {\n        memo++;\n        batch.push(row);\n\n        if (memo % 20 === 0 || memo === result.length) {\n          return ddl.trx.queryBuilder().table(target).insert((0, _lodash.map)(batch, iterator)).then(function () {\n            batch = [];\n          }).thenReturn(memo);\n        }\n\n        return memo;\n      }, 0);\n    };\n  },\n  createTempTable: function createTempTable(createTable) {\n    return function () {\n      return this.trx.raw(createTable.sql.replace(this.tableName, this.alteredName));\n    };\n  },\n  _doReplace: function _doReplace(sql, from, to) {\n    var matched = sql.match(/^CREATE TABLE (\\S+) \\((.*)\\)/);\n    var tableName = matched[1];\n    var defs = matched[2];\n\n    if (!defs) {\n      throw new Error('No column definitions in this statement!');\n    }\n\n    var parens = 0,\n        args = [],\n        ptr = 0;\n    var i = 0;\n    var x = defs.length;\n\n    for (i = 0; i < x; i++) {\n      switch (defs[i]) {\n        case '(':\n          parens++;\n          break;\n\n        case ')':\n          parens--;\n          break;\n\n        case ',':\n          if (parens === 0) {\n            args.push(defs.slice(ptr, i));\n            ptr = i + 1;\n          }\n\n          break;\n\n        case ' ':\n          if (ptr === i) {\n            ptr = i + 1;\n          }\n\n          break;\n      }\n    }\n\n    args.push(defs.slice(ptr, i)); // Backwards compatible for double quoted sqlite databases\n    // Detect CREATE TABLE \"accounts\" (\"id\"...)\n    // The \"from\" and \"to\" field use backsticks, because this is the default notation for\n    // SQlite3 since Knex 0.14.\n    // e.g. from: `about`\n    //\n    // We have to replace the from+to field with double slashes in case you created your SQlite3\n    // database with Knex < 0.14.\n\n    if (sql.match(/CREATE\\sTABLE\\s\".*\"\\s\\(\"/)) {\n      from = from.replace(/[`]/g, '\"');\n      to = to.replace(/[`]/g, '\"');\n    }\n\n    args = args.map(function (item) {\n      var split = item.split(' ');\n\n      if (split[0] === from) {\n        // column definition\n        if (to) {\n          split[0] = to;\n          return split.join(' ');\n        }\n\n        return ''; // for deletions\n      } // skip constraint name\n\n\n      var idx = /constraint/i.test(split[0]) ? 2 : 0; // primary key and unique constraints have one or more\n      // columns from this table listed between (); replace\n      // one if it matches\n\n      if (/primary|unique/i.test(split[idx])) {\n        return item.replace(/\\(.*\\)/, function (columns) {\n          return columns.replace(from, to);\n        });\n      } // foreign keys have one or more columns from this table\n      // listed between (); replace one if it matches\n      // foreign keys also have a 'references' clause\n      // which may reference THIS table; if it does, replace\n      // column references in that too!\n\n\n      if (/foreign/.test(split[idx])) {\n        split = item.split(/ references /i); // the quoted column names save us from having to do anything\n        // other than a straight replace here\n\n        split[0] = split[0].replace(from, to);\n\n        if (split[1].slice(0, tableName.length) === tableName) {\n          split[1] = split[1].replace(/\\(.*\\)/, function (columns) {\n            return columns.replace(from, to);\n          });\n        }\n\n        return split.join(' references ');\n      }\n\n      return item;\n    });\n    return sql.replace(/\\(.*\\)/, function () {\n      return \"(\".concat(args.join(', '), \")\");\n    }).replace(/,\\s*([,)])/, '$1');\n  },\n  // Boy, this is quite a method.\n  renameColumn: _bluebird.default.method(function (from, to) {\n    var _this = this;\n\n    return this.client.transaction(function (trx) {\n      _this.trx = trx;\n      return _this.getColumn(from).bind(_this).then(_this.getTableSql).then(function (sql) {\n        var a = this.client.wrapIdentifier(from);\n        var b = this.client.wrapIdentifier(to);\n        var createTable = sql[0];\n\n        var newSql = this._doReplace(createTable.sql, a, b);\n\n        if (sql === newSql) {\n          throw new Error('Unable to find the column to change');\n        }\n\n        return _bluebird.default.bind(this).then(this.createTempTable(createTable)).then(this.copyData).then(this.dropOriginal).then(function () {\n          return this.trx.raw(newSql);\n        }).then(this.reinsertData(function (row) {\n          row[to] = row[from];\n          return (0, _lodash.omit)(row, from);\n        })).then(this.dropTempTable);\n      });\n    }, {\n      connection: this.connection\n    });\n  }),\n  dropColumn: _bluebird.default.method(function (columns) {\n    var _this2 = this;\n\n    return this.client.transaction(function (trx) {\n      _this2.trx = trx;\n      return _bluebird.default.all(columns.map(function (column) {\n        return _this2.getColumn(column);\n      })).bind(_this2).then(_this2.getTableSql).then(function (sql) {\n        var _this3 = this;\n\n        var createTable = sql[0];\n        var newSql = createTable.sql;\n        columns.forEach(function (column) {\n          var a = _this3.client.wrapIdentifier(column);\n\n          newSql = _this3._doReplace(newSql, a, '');\n        });\n\n        if (sql === newSql) {\n          throw new Error('Unable to find the column to change');\n        }\n\n        return _bluebird.default.bind(this).then(this.createTempTable(createTable)).then(this.copyData).then(this.dropOriginal).then(function () {\n          return this.trx.raw(newSql);\n        }).then(this.reinsertData(function (row) {\n          return (0, _lodash.omit).apply(void 0, [row].concat(_toConsumableArray(columns)));\n        })).then(this.dropTempTable);\n      });\n    }, {\n      connection: this.connection\n    });\n  })\n});\nvar _default = SQLite3_DDL;\nexports.default = _default;\nmodule.exports = exports.default;","map":null,"metadata":{},"sourceType":"script"}