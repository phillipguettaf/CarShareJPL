{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _construct = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/construct\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _bluebird = _interopRequireDefault(require(\"bluebird\"));\n\nvar _raw = _interopRequireDefault(require(\"./raw\"));\n\nvar _ref = _interopRequireDefault(require(\"./ref\"));\n\nvar _runner = _interopRequireDefault(require(\"./runner\"));\n\nvar _formatter = _interopRequireDefault(require(\"./formatter\"));\n\nvar _transaction = _interopRequireDefault(require(\"./transaction\"));\n\nvar _builder = _interopRequireDefault(require(\"./query/builder\"));\n\nvar _compiler = _interopRequireDefault(require(\"./query/compiler\"));\n\nvar _builder2 = _interopRequireDefault(require(\"./schema/builder\"));\n\nvar _compiler2 = _interopRequireDefault(require(\"./schema/compiler\"));\n\nvar _tablebuilder = _interopRequireDefault(require(\"./schema/tablebuilder\"));\n\nvar _tablecompiler = _interopRequireDefault(require(\"./schema/tablecompiler\"));\n\nvar _columnbuilder = _interopRequireDefault(require(\"./schema/columnbuilder\"));\n\nvar _columncompiler = _interopRequireDefault(require(\"./schema/columncompiler\"));\n\nvar _tarn = require(\"tarn\");\n\nvar _inherits = _interopRequireDefault(require(\"inherits\"));\n\nvar _events = require(\"events\");\n\nvar _string = require(\"./query/string\");\n\nvar _lodash = require(\"lodash\");\n\nvar _logger = _interopRequireDefault(require(\"./logger\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar debug = require('debug')('knex:client');\n\nvar debugQuery = require('debug')('knex:query');\n\nvar debugBindings = require('debug')('knex:bindings');\n\nvar _require = require('./constants'),\n    POOL_CONFIG_OPTIONS = _require.POOL_CONFIG_OPTIONS; // The base client provides the general structure\n// for a dialect specific client object.\n\n\nfunction Client() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  this.config = config;\n  this.logger = new _logger.default(config); //Client is a required field, so throw error if it's not supplied.\n  //If 'this.dialect' is set, then this is a 'super()' call, in which case\n  //'client' does not have to be set as it's already assigned on the client prototype.\n\n  if (this.dialect && !this.config.client) {\n    this.logger.warn(\"Using 'this.dialect' to identify the client is deprecated and support for it will be removed in the future. Please use configuration option 'client' instead.\");\n  }\n\n  var dbClient = this.config.client || this.dialect;\n\n  if (!dbClient) {\n    throw new Error(\"knex: Required configuration option 'client' is missing.\");\n  }\n\n  if (config.version) {\n    this.version = config.version;\n  }\n\n  this.connectionSettings = (0, _lodash.cloneDeep)(config.connection || {});\n\n  if (this.driverName && config.connection) {\n    this.initializeDriver();\n\n    if (!config.pool || config.pool && config.pool.max !== 0) {\n      this.initializePool(config);\n    }\n  }\n\n  this.valueForUndefined = this.raw('DEFAULT');\n\n  if (config.useNullAsDefault) {\n    this.valueForUndefined = null;\n  }\n}\n\n(0, _inherits.default)(Client, _events.EventEmitter);\n(0, _lodash.assign)(Client.prototype, {\n  formatter: function formatter(builder) {\n    return new _formatter.default(this, builder);\n  },\n  queryBuilder: function queryBuilder() {\n    return new _builder.default(this);\n  },\n  queryCompiler: function queryCompiler(builder) {\n    return new _compiler.default(this, builder);\n  },\n  schemaBuilder: function schemaBuilder() {\n    return new _builder2.default(this);\n  },\n  schemaCompiler: function schemaCompiler(builder) {\n    return new _compiler2.default(this, builder);\n  },\n  tableBuilder: function tableBuilder(type, tableName, fn) {\n    return new _tablebuilder.default(this, type, tableName, fn);\n  },\n  tableCompiler: function tableCompiler(tableBuilder) {\n    return new _tablecompiler.default(this, tableBuilder);\n  },\n  columnBuilder: function columnBuilder(tableBuilder, type, args) {\n    return new _columnbuilder.default(this, tableBuilder, type, args);\n  },\n  columnCompiler: function columnCompiler(tableBuilder, columnBuilder) {\n    return new _columncompiler.default(this, tableBuilder, columnBuilder);\n  },\n  runner: function runner(builder) {\n    return new _runner.default(this, builder);\n  },\n  transaction: function transaction(container, config, outerTx) {\n    return new _transaction.default(this, container, config, outerTx);\n  },\n  raw: function raw() {\n    var _ref2;\n\n    return (_ref2 = new _raw.default(this)).set.apply(_ref2, arguments);\n  },\n  ref: function ref() {\n    return _construct(_ref.default, [this].concat(Array.prototype.slice.call(arguments)));\n  },\n  _formatQuery: function _formatQuery(sql, bindings, timeZone) {\n    var _this = this;\n\n    bindings = bindings == null ? [] : [].concat(bindings);\n    var index = 0;\n    return sql.replace(/\\\\?\\?/g, function (match) {\n      if (match === '\\\\?') {\n        return '?';\n      }\n\n      if (index === bindings.length) {\n        return match;\n      }\n\n      var value = bindings[index++];\n      return _this._escapeBinding(value, {\n        timeZone: timeZone\n      });\n    });\n  },\n  _escapeBinding: (0, _string.makeEscape)({\n    escapeString: function escapeString(str) {\n      return \"'\".concat(str.replace(/'/g, \"''\"), \"'\");\n    }\n  }),\n  query: function query(connection, obj) {\n    var _this2 = this;\n\n    if (typeof obj === 'string') obj = {\n      sql: obj\n    };\n    obj.bindings = this.prepBindings(obj.bindings);\n    var __knexUid = connection.__knexUid,\n        __knexTxId = connection.__knexTxId;\n    this.emit('query', (0, _lodash.assign)({\n      __knexUid: __knexUid,\n      __knexTxId: __knexTxId\n    }, obj));\n    debugQuery(obj.sql, __knexTxId);\n    debugBindings(obj.bindings, __knexTxId);\n    obj.sql = this.positionBindings(obj.sql);\n    return this._query(connection, obj).catch(function (err) {\n      err.message = _this2._formatQuery(obj.sql, obj.bindings) + ' - ' + err.message;\n\n      _this2.emit('query-error', err, (0, _lodash.assign)({\n        __knexUid: __knexUid,\n        __knexTxId: __knexTxId\n      }, obj));\n\n      throw err;\n    });\n  },\n  stream: function stream(connection, obj, _stream, options) {\n    if (typeof obj === 'string') obj = {\n      sql: obj\n    };\n    obj.bindings = this.prepBindings(obj.bindings);\n    var __knexUid = connection.__knexUid,\n        __knexTxId = connection.__knexTxId;\n    this.emit('query', (0, _lodash.assign)({\n      __knexUid: __knexUid,\n      __knexTxId: __knexTxId\n    }, obj));\n    debugQuery(obj.sql, __knexTxId);\n    debugBindings(obj.bindings, __knexTxId);\n    obj.sql = this.positionBindings(obj.sql);\n    return this._stream(connection, obj, _stream, options);\n  },\n  prepBindings: function prepBindings(bindings) {\n    return bindings;\n  },\n  positionBindings: function positionBindings(sql) {\n    return sql;\n  },\n  postProcessResponse: function postProcessResponse(resp, queryContext) {\n    if (this.config.postProcessResponse) {\n      return this.config.postProcessResponse(resp, queryContext);\n    }\n\n    return resp;\n  },\n  wrapIdentifier: function wrapIdentifier(value, queryContext) {\n    return this.customWrapIdentifier(value, this.wrapIdentifierImpl, queryContext);\n  },\n  customWrapIdentifier: function customWrapIdentifier(value, origImpl, queryContext) {\n    if (this.config.wrapIdentifier) {\n      return this.config.wrapIdentifier(value, origImpl, queryContext);\n    }\n\n    return origImpl(value);\n  },\n  wrapIdentifierImpl: function wrapIdentifierImpl(value) {\n    return value !== '*' ? \"\\\"\".concat(value.replace(/\"/g, '\"\"'), \"\\\"\") : '*';\n  },\n  initializeDriver: function initializeDriver() {\n    try {\n      this.driver = this._driver();\n    } catch (e) {\n      var message = \"Knex: run\\n$ npm install \".concat(this.driverName, \" --save\");\n      this.logger.error(\"\".concat(message, \"\\n\").concat(e.message, \"\\n\").concat(e.stack));\n      throw new Error(\"\".concat(message, \"\\n\").concat(e.message));\n    }\n  },\n  poolDefaults: function poolDefaults() {\n    return {\n      min: 2,\n      max: 10,\n      propagateCreateError: true\n    };\n  },\n  getPoolSettings: function getPoolSettings(poolConfig) {\n    var _this3 = this;\n\n    poolConfig = (0, _lodash.defaults)({}, poolConfig, this.poolDefaults());\n    POOL_CONFIG_OPTIONS.forEach(function (option) {\n      if (option in poolConfig) {\n        _this3.logger.warn([\"Pool config option \\\"\".concat(option, \"\\\" is no longer supported.\"), \"See https://github.com/Vincit/tarn.js for possible pool config options.\"].join(' '));\n      }\n    });\n    var timeouts = [this.config.acquireConnectionTimeout || 60000, poolConfig.acquireTimeoutMillis].filter(function (timeout) {\n      return timeout !== undefined;\n    }); // acquire connection timeout can be set on config or config.pool\n    // choose the smallest, positive timeout setting and set on poolConfig\n\n    poolConfig.acquireTimeoutMillis = Math.min.apply(Math, _toConsumableArray(timeouts));\n    return Object.assign(poolConfig, {\n      create: function create() {\n        return _this3.acquireRawConnection().tap(function (connection) {\n          connection.__knexUid = (0, _lodash.uniqueId)('__knexUid');\n\n          if (poolConfig.afterCreate) {\n            return _bluebird.default.promisify(poolConfig.afterCreate)(connection);\n          }\n        });\n      },\n      destroy: function destroy(connection) {\n        if (poolConfig.beforeDestroy) {\n          _this3.logger.warn(\"\\n            beforeDestroy is deprecated, please open an issue if you use this\\n            to discuss alternative apis\\n          \");\n\n          poolConfig.beforeDestroy(connection, function () {});\n        }\n\n        if (connection !== void 0) {\n          return _this3.destroyRawConnection(connection);\n        }\n      },\n      validate: function validate(connection) {\n        if (connection.__knex__disposed) {\n          _this3.logger.warn(\"Connection Error: \".concat(connection.__knex__disposed));\n\n          return false;\n        }\n\n        return _this3.validateConnection(connection);\n      }\n    });\n  },\n  initializePool: function initializePool() {\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.config;\n\n    if (this.pool) {\n      this.logger.warn('The pool has already been initialized');\n      return;\n    }\n\n    this.pool = new _tarn.Pool(this.getPoolSettings(config.pool));\n  },\n  validateConnection: function validateConnection(connection) {\n    return true;\n  },\n  // Acquire a connection from the pool.\n  acquireConnection: function acquireConnection() {\n    var _this4 = this;\n\n    if (!this.pool) {\n      return _bluebird.default.reject(new Error('Unable to acquire a connection'));\n    }\n\n    return _bluebird.default.try(function () {\n      return _this4.pool.acquire().promise;\n    }).tap(function (connection) {\n      debug('acquired connection from pool: %s', connection.__knexUid);\n    }).catch(_tarn.TimeoutError, function () {\n      throw new _bluebird.default.TimeoutError('Knex: Timeout acquiring a connection. The pool is probably full. ' + 'Are you missing a .transacting(trx) call?');\n    });\n  },\n  // Releases a connection back to the connection pool,\n  // returning a promise resolved when the connection is released.\n  releaseConnection: function releaseConnection(connection) {\n    debug('releasing connection to pool: %s', connection.__knexUid);\n    var didRelease = this.pool.release(connection);\n\n    if (!didRelease) {\n      debug('pool refused connection: %s', connection.__knexUid);\n    }\n\n    return _bluebird.default.resolve();\n  },\n  // Destroy the current connection pool for the client.\n  destroy: function destroy(callback) {\n    var _this5 = this;\n\n    var maybeDestroy = this.pool && this.pool.destroy();\n    return _bluebird.default.resolve(maybeDestroy).then(function () {\n      _this5.pool = void 0;\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n    }).catch(function (err) {\n      if (typeof callback === 'function') {\n        callback(err);\n      }\n\n      return _bluebird.default.reject(err);\n    });\n  },\n  // Return the database being used by this client.\n  database: function database() {\n    return this.connectionSettings.database;\n  },\n  toString: function toString() {\n    return '[object KnexClient]';\n  },\n  canCancelQuery: false,\n  assertCanCancelQuery: function assertCanCancelQuery() {\n    if (!this.canCancelQuery) {\n      throw new Error('Query cancelling not supported for this dialect');\n    }\n  },\n  cancelQuery: function cancelQuery() {\n    throw new Error('Query cancelling not supported for this dialect');\n  }\n});\nvar _default = Client;\nexports.default = _default;\nmodule.exports = exports.default;","map":null,"metadata":{},"sourceType":"script"}