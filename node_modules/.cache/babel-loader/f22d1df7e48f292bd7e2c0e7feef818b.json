{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _builder = _interopRequireDefault(require(\"./query/builder\"));\n\nvar _raw = _interopRequireDefault(require(\"./raw\"));\n\nvar _lodash = require(\"lodash\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // Valid values for the `order by` clause generation.\n\n\nvar orderBys = ['asc', 'desc']; // Turn this into a lookup map\n\nvar operators = (0, _lodash.transform)(['=', '<', '>', '<=', '>=', '<>', '!=', 'like', 'not like', 'between', 'not between', 'ilike', 'not ilike', 'exists', 'not exist', 'rlike', 'not rlike', 'regexp', 'not regexp', '&', '|', '^', '<<', '>>', '~', '~*', '!~', '!~*', '#', '&&', '@>', '<@', '||', '&<', '&>', '-|-', '@@', '!!', ['?', '\\\\?'], ['?|', '\\\\?|'], ['?&', '\\\\?&']], function (result, key) {\n  if (Array.isArray(key)) {\n    result[key[0]] = key[1];\n  } else {\n    result[key] = key;\n  }\n}, {});\n\nvar Formatter =\n/*#__PURE__*/\nfunction () {\n  function Formatter(client, builder) {\n    _classCallCheck(this, Formatter);\n\n    this.client = client;\n    this.builder = builder;\n    this.bindings = [];\n  } // Accepts a string or array of columns to wrap as appropriate.\n\n\n  _createClass(Formatter, [{\n    key: \"columnize\",\n    value: function columnize(target) {\n      var columns = Array.isArray(target) ? target : [target];\n      var str = '',\n          i = -1;\n\n      while (++i < columns.length) {\n        if (i > 0) str += ', ';\n        str += this.wrap(columns[i]);\n      }\n\n      return str;\n    } // Turns a list of values into a list of ?'s, joining them with commas unless\n    // a \"joining\" value is specified (e.g. ' and ')\n\n  }, {\n    key: \"parameterize\",\n    value: function parameterize(values, notSetValue) {\n      if (typeof values === 'function') return this.parameter(values);\n      values = Array.isArray(values) ? values : [values];\n      var str = '',\n          i = -1;\n\n      while (++i < values.length) {\n        if (i > 0) str += ', ';\n        str += this.parameter(values[i] === undefined ? notSetValue : values[i]);\n      }\n\n      return str;\n    } // Formats `values` into a parenthesized list of parameters for a `VALUES`\n    // clause.\n    //\n    // [1, 2]                  -> '(?, ?)'\n    // [[1, 2], [3, 4]]        -> '((?, ?), (?, ?))'\n    // knex('table')           -> '(select * from \"table\")'\n    // knex.raw('select ?', 1) -> '(select ?)'\n    //\n\n  }, {\n    key: \"values\",\n    value: function values(_values) {\n      var _this = this;\n\n      if (Array.isArray(_values)) {\n        if (Array.isArray(_values[0])) {\n          return \"(\".concat(_values.map(function (value) {\n            return \"(\".concat(_this.parameterize(value), \")\");\n          }).join(', '), \")\");\n        }\n\n        return \"(\".concat(this.parameterize(_values), \")\");\n      }\n\n      if (_values instanceof _raw.default) {\n        return \"(\".concat(this.parameter(_values), \")\");\n      }\n\n      return this.parameter(_values);\n    } // Checks whether a value is a function... if it is, we compile it\n    // otherwise we check whether it's a raw\n\n  }, {\n    key: \"parameter\",\n    value: function parameter(value) {\n      if (typeof value === 'function') {\n        return this.outputQuery(this.compileCallback(value), true);\n      }\n\n      return this.unwrapRaw(value, true) || '?';\n    }\n  }, {\n    key: \"unwrapRaw\",\n    value: function unwrapRaw(value, isParameter) {\n      var query;\n\n      if (value instanceof _builder.default) {\n        query = this.client.queryCompiler(value).toSQL();\n\n        if (query.bindings) {\n          this.bindings = this.bindings.concat(query.bindings);\n        }\n\n        return this.outputQuery(query, isParameter);\n      }\n\n      if (value instanceof _raw.default) {\n        value.client = this.client;\n        query = value.toSQL();\n\n        if (query.bindings) {\n          this.bindings = this.bindings.concat(query.bindings);\n        }\n\n        return query.sql;\n      }\n\n      if (isParameter) {\n        this.bindings.push(value);\n      }\n    }\n    /**\n     * Creates SQL for a parameter, which might be passed to where() or .with() or\n     * pretty much anywhere in API.\n     *\n     * @param query Callback (for where or complete builder), Raw or QueryBuilder\n     * @param method Optional at least 'select' or 'update' are valid\n     */\n\n  }, {\n    key: \"rawOrFn\",\n    value: function rawOrFn(value, method) {\n      if (typeof value === 'function') {\n        return this.outputQuery(this.compileCallback(value, method));\n      }\n\n      return this.unwrapRaw(value) || '';\n    } // Puts the appropriate wrapper around a value depending on the database\n    // engine, unless it's a knex.raw value, in which case it's left alone.\n\n  }, {\n    key: \"wrap\",\n    value: function wrap(value) {\n      var raw = this.unwrapRaw(value);\n      if (raw) return raw;\n\n      switch (typeof value) {\n        case 'function':\n          return this.outputQuery(this.compileCallback(value), true);\n\n        case 'object':\n          return this.parseObject(value);\n\n        case 'number':\n          return value;\n\n        default:\n          return this.wrapString(value + '');\n      }\n    }\n  }, {\n    key: \"wrapAsIdentifier\",\n    value: function wrapAsIdentifier(value) {\n      var queryContext = this.builder.queryContext();\n      return this.client.wrapIdentifier((value || '').trim(), queryContext);\n    }\n  }, {\n    key: \"alias\",\n    value: function alias(first, second) {\n      return first + ' as ' + second;\n    }\n  }, {\n    key: \"operator\",\n    value: function operator(value) {\n      var raw = this.unwrapRaw(value);\n      if (raw) return raw;\n      var operator = operators[(value || '').toLowerCase()];\n\n      if (!operator) {\n        throw new TypeError(\"The operator \\\"\".concat(value, \"\\\" is not permitted\"));\n      }\n\n      return operator;\n    } // Specify the direction of the ordering.\n\n  }, {\n    key: \"direction\",\n    value: function direction(value) {\n      var raw = this.unwrapRaw(value);\n      if (raw) return raw;\n      return orderBys.indexOf((value || '').toLowerCase()) !== -1 ? value : 'asc';\n    } // Compiles a callback using the query builder.\n\n  }, {\n    key: \"compileCallback\",\n    value: function compileCallback(callback, method) {\n      var client = this.client; // Build the callback\n\n      var builder = client.queryBuilder();\n      callback.call(builder, builder); // Compile the callback, using the current formatter (to track all bindings).\n\n      var compiler = client.queryCompiler(builder);\n      compiler.formatter = this; // Return the compiled & parameterized sql.\n\n      return compiler.toSQL(method || builder._method || 'select');\n    } // Ensures the query is aliased if necessary.\n\n  }, {\n    key: \"outputQuery\",\n    value: function outputQuery(compiled, isParameter) {\n      var sql = compiled.sql || '';\n\n      if (sql) {\n        if ((compiled.method === 'select' || compiled.method === 'first') && (isParameter || compiled.as)) {\n          sql = \"(\".concat(sql, \")\");\n          if (compiled.as) return this.alias(sql, this.wrap(compiled.as));\n        }\n      }\n\n      return sql;\n    } // Key-value notation for alias\n\n  }, {\n    key: \"parseObject\",\n    value: function parseObject(obj) {\n      var ret = [];\n\n      for (var alias in obj) {\n        var queryOrIdentifier = obj[alias]; // Avoids double aliasing for subqueries\n\n        if (typeof queryOrIdentifier === 'function') {\n          var compiled = this.compileCallback(queryOrIdentifier);\n          compiled.as = alias; // enforces the object's alias\n\n          ret.push(this.outputQuery(compiled, true));\n        } else if (queryOrIdentifier instanceof _builder.default) {\n          ret.push(this.alias(\"(\".concat(this.wrap(queryOrIdentifier), \")\"), this.wrapAsIdentifier(alias)));\n        } else {\n          ret.push(this.alias(this.wrap(queryOrIdentifier), this.wrapAsIdentifier(alias)));\n        }\n      }\n\n      return ret.join(', ');\n    } // Coerce to string to prevent strange errors when it's not a string.\n\n  }, {\n    key: \"wrapString\",\n    value: function wrapString(value) {\n      var asIndex = value.toLowerCase().indexOf(' as ');\n\n      if (asIndex !== -1) {\n        var first = value.slice(0, asIndex);\n        var second = value.slice(asIndex + 4);\n        return this.alias(this.wrap(first), this.wrapAsIdentifier(second));\n      }\n\n      var wrapped = [];\n      var i = -1;\n      var segments = value.split('.');\n\n      while (++i < segments.length) {\n        value = segments[i];\n\n        if (i === 0 && segments.length > 1) {\n          wrapped.push(this.wrap((value || '').trim()));\n        } else {\n          wrapped.push(this.wrapAsIdentifier(value));\n        }\n      }\n\n      return wrapped.join('.');\n    }\n  }]);\n\n  return Formatter;\n}();\n\nexports.default = Formatter;\nmodule.exports = exports.default;","map":null,"metadata":{},"sourceType":"script"}