{"ast":null,"code":"\"use strict\"; // Oracledb Client\n// -------\n\nvar _classCallCheck = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _construct = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/construct\");\n\nvar _ = require('lodash');\n\nvar inherits = require('inherits');\n\nvar QueryCompiler = require('./query/compiler');\n\nvar ColumnCompiler = require('./schema/columncompiler');\n\nvar BlobHelper = require('./utils').BlobHelper;\n\nvar ReturningHelper = require('./utils').ReturningHelper;\n\nvar Promise = require('bluebird');\n\nvar stream = require('stream');\n\nvar Transaction = require('./transaction');\n\nvar Client_Oracle = require('../oracle');\n\nvar Oracle_Formatter = require('../oracle/formatter');\n\nfunction Client_Oracledb() {\n  Client_Oracle.apply(this, arguments); // Node.js only have 4 background threads by default, oracledb needs one by connection\n\n  if (this.driver) {\n    process.env.UV_THREADPOOL_SIZE = process.env.UV_THREADPOOL_SIZE || 1;\n    process.env.UV_THREADPOOL_SIZE = parseInt(process.env.UV_THREADPOOL_SIZE) + this.driver.poolMax;\n  }\n}\n\ninherits(Client_Oracledb, Client_Oracle);\nClient_Oracledb.prototype.driverName = 'oracledb';\n\nClient_Oracledb.prototype._driver = function () {\n  var client = this;\n\n  var oracledb = require('oracledb');\n\n  client.fetchAsString = [];\n\n  if (this.config.fetchAsString && _.isArray(this.config.fetchAsString)) {\n    this.config.fetchAsString.forEach(function (type) {\n      if (!_.isString(type)) return;\n      type = type.toUpperCase();\n\n      if (oracledb[type]) {\n        if (type !== 'NUMBER' && type !== 'DATE' && type !== 'CLOB') {\n          this.logger.warn('Only \"date\", \"number\" and \"clob\" are supported for fetchAsString');\n        }\n\n        client.fetchAsString.push(oracledb[type]);\n      }\n    });\n  }\n\n  return oracledb;\n};\n\nClient_Oracledb.prototype.queryCompiler = function () {\n  return _construct(QueryCompiler, [this].concat(Array.prototype.slice.call(arguments)));\n};\n\nClient_Oracledb.prototype.columnCompiler = function () {\n  return _construct(ColumnCompiler, [this].concat(Array.prototype.slice.call(arguments)));\n};\n\nClient_Oracledb.prototype.formatter = function () {\n  return _construct(Oracledb_Formatter, [this].concat(Array.prototype.slice.call(arguments)));\n};\n\nClient_Oracledb.prototype.transaction = function () {\n  return _construct(Transaction, [this].concat(Array.prototype.slice.call(arguments)));\n};\n\nClient_Oracledb.prototype.prepBindings = function (bindings) {\n  var _this = this;\n\n  return _.map(bindings, function (value) {\n    if (value instanceof BlobHelper && _this.driver) {\n      return {\n        type: _this.driver.BLOB,\n        dir: _this.driver.BIND_OUT\n      }; // Returning helper always use ROWID as string\n    } else if (value instanceof ReturningHelper && _this.driver) {\n      return {\n        type: _this.driver.STRING,\n        dir: _this.driver.BIND_OUT\n      };\n    } else if (typeof value === 'boolean') {\n      return value ? 1 : 0;\n    }\n\n    return value;\n  });\n}; // Get a raw connection, called by the `pool` whenever a new\n// connection needs to be added to the pool.\n\n\nClient_Oracledb.prototype.acquireRawConnection = function () {\n  var client = this;\n  var asyncConnection = new Promise(function (resolver, rejecter) {\n    // If external authentication dont have to worry about username/password and\n    // if not need to set the username and password\n    var oracleDbConfig = client.connectionSettings.externalAuth ? {\n      externalAuth: client.connectionSettings.externalAuth\n    } : {\n      user: client.connectionSettings.user,\n      password: client.connectionSettings.password\n    }; // In the case of external authentication connection string will be given\n\n    oracleDbConfig.connectString = client.connectionSettings.connectString || client.connectionSettings.host + '/' + client.connectionSettings.database;\n\n    if (client.connectionSettings.prefetchRowCount) {\n      oracleDbConfig.prefetchRows = client.connectionSettings.prefetchRowCount;\n    }\n\n    if (!_.isUndefined(client.connectionSettings.stmtCacheSize)) {\n      oracleDbConfig.stmtCacheSize = client.connectionSettings.stmtCacheSize;\n    }\n\n    client.driver.fetchAsString = client.fetchAsString;\n    client.driver.getConnection(oracleDbConfig, function (err, connection) {\n      if (err) {\n        return rejecter(err);\n      }\n\n      connection.commitAsync = function () {\n        var _this2 = this;\n\n        return new Promise(function (commitResolve, commitReject) {\n          if (connection.isTransaction) {\n            return commitResolve();\n          }\n\n          _this2.commit(function (err) {\n            if (err) {\n              return commitReject(err);\n            }\n\n            commitResolve();\n          });\n        });\n      };\n\n      connection.rollbackAsync = function () {\n        var _this3 = this;\n\n        return new Promise(function (rollbackResolve, rollbackReject) {\n          _this3.rollback(function (err) {\n            if (err) {\n              return rollbackReject(err);\n            }\n\n            rollbackResolve();\n          });\n        });\n      };\n\n      var fetchAsync = function fetchAsync(sql, bindParams, options, cb) {\n        options = options || {};\n        options.outFormat = client.driver.OBJECT;\n\n        if (options.resultSet) {\n          connection.execute(sql, bindParams || [], options, function (err, result) {\n            if (err) {\n              return cb(err);\n            }\n\n            var fetchResult = {\n              rows: [],\n              resultSet: result.resultSet\n            };\n            var numRows = 100;\n\n            var fetchRowsFromRS = function fetchRowsFromRS(connection, resultSet, numRows) {\n              resultSet.getRows(numRows, function (err, rows) {\n                if (err) {\n                  resultSet.close(function () {\n                    return cb(err);\n                  });\n                } else if (rows.length === 0) {\n                  return cb(null, fetchResult);\n                } else if (rows.length > 0) {\n                  if (rows.length === numRows) {\n                    fetchResult.rows = fetchResult.rows.concat(rows);\n                    fetchRowsFromRS(connection, resultSet, numRows);\n                  } else {\n                    fetchResult.rows = fetchResult.rows.concat(rows);\n                    return cb(null, fetchResult);\n                  }\n                }\n              });\n            };\n\n            fetchRowsFromRS(connection, result.resultSet, numRows);\n          });\n        } else {\n          connection.execute(sql, bindParams || [], options, cb);\n        }\n      };\n\n      connection.executeAsync = function (sql, bindParams, options) {\n        // Read all lob\n        return new Promise(function (resultResolve, resultReject) {\n          fetchAsync(sql, bindParams, options, function (err, results) {\n            if (err) {\n              return resultReject(err);\n            } // Collect LOBs to read\n\n\n            var lobs = [];\n\n            if (results.rows) {\n              if (Array.isArray(results.rows)) {\n                for (var i = 0; i < results.rows.length; i++) {\n                  // Iterate through the rows\n                  var row = results.rows[i];\n\n                  for (var column in row) {\n                    if (row[column] instanceof stream.Readable) {\n                      lobs.push({\n                        index: i,\n                        key: column,\n                        stream: row[column]\n                      });\n                    }\n                  }\n                }\n              }\n            }\n\n            Promise.each(lobs, function (lob) {\n              return new Promise(function (lobResolve, lobReject) {\n                readStream(lob.stream, function (err, d) {\n                  if (err) {\n                    if (results.resultSet) {\n                      results.resultSet.close(function () {\n                        return lobReject(err);\n                      });\n                    }\n\n                    return lobReject(err);\n                  }\n\n                  results.rows[lob.index][lob.key] = d;\n                  lobResolve();\n                });\n              });\n            }).then(function () {\n              if (results.resultSet) {\n                results.resultSet.close(function (err) {\n                  if (err) {\n                    return resultReject(err);\n                  }\n\n                  return resultResolve(results);\n                });\n              }\n\n              resultResolve(results);\n            }, function (err) {\n              resultReject(err);\n            });\n          });\n        });\n      };\n\n      resolver(connection);\n    });\n  });\n  return asyncConnection;\n}; // Used to explicitly close a connection, called internally by the pool\n// when a connection times out or the pool is shutdown.\n\n\nClient_Oracledb.prototype.destroyRawConnection = function (connection) {\n  return connection.release();\n}; // Runs the query on the specified connection, providing the bindings\n// and any other necessary prep work.\n\n\nClient_Oracledb.prototype._query = function (connection, obj) {\n  return new Promise(function (resolver, rejecter) {\n    if (!obj.sql) {\n      return rejecter(new Error('The query is empty'));\n    }\n\n    var options = {\n      autoCommit: false\n    };\n\n    if (obj.method === 'select') {\n      options.resultSet = true;\n    }\n\n    connection.executeAsync(obj.sql, obj.bindings, options).then(function (response) {\n      // Flatten outBinds\n      var outBinds = _.flatten(response.outBinds);\n\n      obj.response = response.rows || [];\n      obj.rowsAffected = response.rows ? response.rows.rowsAffected : response.rowsAffected;\n\n      if (obj.method === 'update') {\n        var modifiedRowsCount = obj.rowsAffected.length || obj.rowsAffected;\n        var updatedObjOutBinding = [];\n        var updatedOutBinds = [];\n\n        var updateOutBinds = function updateOutBinds(i) {\n          return function (value, index) {\n            var OutBindsOffset = index * modifiedRowsCount;\n            updatedOutBinds.push(outBinds[i + OutBindsOffset]);\n          };\n        };\n\n        for (var i = 0; i < modifiedRowsCount; i++) {\n          updatedObjOutBinding.push(obj.outBinding[0]);\n\n          _.each(obj.outBinding[0], updateOutBinds(i));\n        }\n\n        outBinds = updatedOutBinds;\n        obj.outBinding = updatedObjOutBinding;\n      }\n\n      if (!obj.returning && outBinds.length === 0) {\n        return connection.commitAsync().then(function () {\n          resolver(obj);\n        });\n      }\n\n      var rowIds = [];\n      var offset = 0;\n      Promise.each(obj.outBinding, function (ret, line) {\n        offset = offset + (obj.outBinding[line - 1] ? obj.outBinding[line - 1].length : 0);\n        return Promise.each(ret, function (out, index) {\n          return new Promise(function (bindResolver, bindRejecter) {\n            if (out instanceof BlobHelper) {\n              var blob = outBinds[index + offset];\n\n              if (out.returning) {\n                obj.response[line] = obj.response[line] || {};\n                obj.response[line][out.columnName] = out.value;\n              }\n\n              blob.on('error', function (err) {\n                bindRejecter(err);\n              });\n              blob.on('finish', function () {\n                bindResolver();\n              });\n              blob.write(out.value);\n              blob.end();\n            } else if (obj.outBinding[line][index] === 'ROWID') {\n              rowIds.push(outBinds[index + offset]);\n              bindResolver();\n            } else {\n              obj.response[line] = obj.response[line] || {};\n              obj.response[line][out] = outBinds[index + offset];\n              bindResolver();\n            }\n          });\n        });\n      }).then(function () {\n        return connection.commitAsync();\n      }).then(function () {\n        if (obj.returningSql) {\n          return connection.executeAsync(obj.returningSql(), rowIds, {\n            resultSet: true\n          }).then(function (response) {\n            obj.response = response.rows;\n            return obj;\n          }, rejecter);\n        }\n\n        return obj;\n      }, rejecter).then(function (obj) {\n        resolver(obj);\n      });\n    }, rejecter);\n  });\n}; // Handle clob\n\n\nfunction readStream(stream, cb) {\n  var oracledb = require('oracledb');\n\n  var data = '';\n\n  if (stream.iLob.type === oracledb.CLOB) {\n    stream.setEncoding('utf-8');\n  } else {\n    data = Buffer.alloc(0);\n  }\n\n  stream.on('error', function (err) {\n    cb(err);\n  });\n  stream.on('data', function (chunk) {\n    if (stream.iLob.type === oracledb.CLOB) {\n      data += chunk;\n    } else {\n      data = Buffer.concat([data, chunk]);\n    }\n  });\n  stream.on('end', function () {\n    cb(null, data);\n  });\n} // Process the response as returned from the query.\n\n\nClient_Oracledb.prototype.processResponse = function (obj, runner) {\n  var response = obj.response;\n  var method = obj.method;\n\n  if (obj.output) {\n    return obj.output.call(runner, response);\n  }\n\n  switch (method) {\n    case 'select':\n    case 'pluck':\n    case 'first':\n      if (obj.method === 'pluck') {\n        response = _.map(response, obj.pluck);\n      }\n\n      return obj.method === 'first' ? response[0] : response;\n\n    case 'insert':\n    case 'del':\n    case 'update':\n    case 'counter':\n      if (obj.returning && !_.isEmpty(obj.returning)) {\n        if (obj.returning.length === 1 && obj.returning[0] !== '*') {\n          return _.flatten(_.map(response, _.values));\n        }\n\n        return response;\n      } else if (!_.isUndefined(obj.rowsAffected)) {\n        return obj.rowsAffected;\n      } else {\n        return 1;\n      }\n\n    default:\n      return response;\n  }\n};\n\nvar Oracledb_Formatter =\n/*#__PURE__*/\nfunction (_Oracle_Formatter) {\n  _inherits(Oracledb_Formatter, _Oracle_Formatter);\n\n  function Oracledb_Formatter() {\n    _classCallCheck(this, Oracledb_Formatter);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Oracledb_Formatter).apply(this, arguments));\n  }\n\n  _createClass(Oracledb_Formatter, [{\n    key: \"parameter\",\n    // Checks whether a value is a function... if it is, we compile it\n    // otherwise we check whether it's a raw\n    value: function parameter(value) {\n      if (typeof value === 'function') {\n        return this.outputQuery(this.compileCallback(value), true);\n      } else if (value instanceof BlobHelper) {\n        return 'EMPTY_BLOB()';\n      }\n\n      return this.unwrapRaw(value, true) || '?';\n    }\n  }]);\n\n  return Oracledb_Formatter;\n}(Oracle_Formatter);\n\nmodule.exports = Client_Oracledb;","map":null,"metadata":{},"sourceType":"script"}