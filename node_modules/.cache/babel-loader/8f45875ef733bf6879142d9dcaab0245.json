{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _lodash = require(\"lodash\");\n\nvar helpers = _interopRequireWildcard(require(\"../helpers\"));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n} // TableBuilder\n// Takes the function passed to the \"createTable\" or \"table/editTable\"\n// functions and calls it with the \"TableBuilder\" as both the context and\n// the first argument. Inside this function we can specify what happens to the\n// method, pushing everything we want to do onto the \"allStatements\" array,\n// which is then compiled into sql.\n// ------\n\n\nfunction TableBuilder(client, method, tableName, fn) {\n  this.client = client;\n  this._fn = fn;\n  this._method = method;\n  this._schemaName = undefined;\n  this._tableName = tableName;\n  this._statements = [];\n  this._single = {};\n\n  if (!(0, _lodash.isFunction)(this._fn)) {\n    throw new TypeError('A callback function must be supplied to calls against `.createTable` ' + 'and `.table`');\n  }\n}\n\nTableBuilder.prototype.setSchema = function (schemaName) {\n  this._schemaName = schemaName;\n}; // Convert the current tableBuilder object \"toSQL\"\n// giving us additional methods if we're altering\n// rather than creating the table.\n\n\nTableBuilder.prototype.toSQL = function () {\n  if (this._method === 'alter') {\n    (0, _lodash.extend)(this, AlterMethods);\n  }\n\n  this._fn.call(this, this);\n\n  return this.client.tableCompiler(this).toSQL();\n};\n\n(0, _lodash.each)([// Each of the index methods can be called individually, with the\n// column name to be used, e.g. table.unique('column').\n'index', 'primary', 'unique', // Key specific\n'dropPrimary', 'dropUnique', 'dropIndex', 'dropForeign'], function (method) {\n  TableBuilder.prototype[method] = function () {\n    this._statements.push({\n      grouping: 'alterTable',\n      method: method,\n      args: (0, _lodash.toArray)(arguments)\n    });\n\n    return this;\n  };\n}); // Warn for dialect-specific table methods, since that's the\n// only time these are supported.\n\nvar specialMethods = {\n  mysql: ['engine', 'charset', 'collate'],\n  postgresql: ['inherits']\n};\n(0, _lodash.each)(specialMethods, function (methods, dialect) {\n  (0, _lodash.each)(methods, function (method) {\n    TableBuilder.prototype[method] = function (value) {\n      if (this.client.dialect !== dialect) {\n        this.client.logger.warn(\"Knex only supports \".concat(method, \" statement with \").concat(dialect, \".\"));\n      }\n\n      if (this._method === 'alter') {\n        this.client.logger.warn(\"Knex does not support altering the \".concat(method, \" outside of create \") + \"table, please use knex.raw statement.\");\n      }\n\n      this._single[method] = value;\n    };\n  });\n});\nhelpers.addQueryContext(TableBuilder); // Each of the column types that we can add, we create a new ColumnBuilder\n// instance and push it onto the statements array.\n\nvar columnTypes = [// Numeric\n'tinyint', 'smallint', 'mediumint', 'int', 'bigint', 'decimal', 'float', 'double', 'real', 'bit', 'boolean', 'serial', // Date / Time\n'date', 'datetime', 'timestamp', 'time', 'year', // String\n'char', 'varchar', 'tinytext', 'tinyText', 'text', 'mediumtext', 'mediumText', 'longtext', 'longText', 'binary', 'varbinary', 'tinyblob', 'tinyBlob', 'mediumblob', 'mediumBlob', 'blob', 'longblob', 'longBlob', 'enum', 'set', // Increments, Aliases, and Additional\n'bool', 'dateTime', 'increments', 'bigincrements', 'bigIncrements', 'integer', 'biginteger', 'bigInteger', 'string', 'json', 'jsonb', 'uuid', 'enu', 'specificType']; // For each of the column methods, create a new \"ColumnBuilder\" interface,\n// push it onto the \"allStatements\" stack, and then return the interface,\n// with which we can add indexes, etc.\n\n(0, _lodash.each)(columnTypes, function (type) {\n  TableBuilder.prototype[type] = function () {\n    var args = (0, _lodash.toArray)(arguments);\n    var builder = this.client.columnBuilder(this, type, args);\n\n    this._statements.push({\n      grouping: 'columns',\n      builder: builder\n    });\n\n    return builder;\n  };\n}); // The \"timestamps\" call is really just sets the `created_at` and `updated_at` columns.\n\nTableBuilder.prototype.timestamps = function timestamps() {\n  var method = arguments[0] === true ? 'timestamp' : 'datetime';\n  var createdAt = this[method]('created_at');\n  var updatedAt = this[method]('updated_at');\n\n  if (arguments[1] === true) {\n    var now = this.client.raw('CURRENT_TIMESTAMP');\n    createdAt.notNullable().defaultTo(now);\n    updatedAt.notNullable().defaultTo(now);\n  }\n\n  return;\n}; // Set the comment value for a table, they're only allowed to be called\n// once per table.\n\n\nTableBuilder.prototype.comment = function (value) {\n  if (typeof value !== 'string') {\n    throw new TypeError('Table comment must be string');\n  }\n\n  this._single.comment = value;\n}; // Set a foreign key on the table, calling\n// `table.foreign('column_name').references('column').on('table').onDelete()...\n// Also called from the ColumnBuilder context when chaining.\n\n\nTableBuilder.prototype.foreign = function (column, keyName) {\n  var foreignData = {\n    column: column,\n    keyName: keyName\n  };\n\n  this._statements.push({\n    grouping: 'alterTable',\n    method: 'foreign',\n    args: [foreignData]\n  });\n\n  var returnObj = {\n    references: function references(tableColumn) {\n      var pieces;\n\n      if ((0, _lodash.isString)(tableColumn)) {\n        pieces = tableColumn.split('.');\n      }\n\n      if (!pieces || pieces.length === 1) {\n        foreignData.references = pieces ? pieces[0] : tableColumn;\n        return {\n          on: function on(tableName) {\n            if (typeof tableName !== 'string') {\n              throw new TypeError(\"Expected tableName to be a string, got: \".concat(typeof tableName));\n            }\n\n            foreignData.inTable = tableName;\n            return returnObj;\n          },\n          inTable: function inTable() {\n            return this.on.apply(this, arguments);\n          }\n        };\n      }\n\n      foreignData.inTable = pieces[0];\n      foreignData.references = pieces[1];\n      return returnObj;\n    },\n    withKeyName: function withKeyName(keyName) {\n      foreignData.keyName = keyName;\n      return returnObj;\n    },\n    onUpdate: function onUpdate(statement) {\n      foreignData.onUpdate = statement;\n      return returnObj;\n    },\n    onDelete: function onDelete(statement) {\n      foreignData.onDelete = statement;\n      return returnObj;\n    },\n    _columnBuilder: function _columnBuilder(builder) {\n      (0, _lodash.extend)(builder, returnObj);\n      returnObj = builder;\n      return builder;\n    }\n  };\n  return returnObj;\n};\n\nvar AlterMethods = {\n  // Renames the current column `from` the current\n  // TODO: this.column(from).rename(to)\n  renameColumn: function renameColumn(from, to) {\n    this._statements.push({\n      grouping: 'alterTable',\n      method: 'renameColumn',\n      args: [from, to]\n    });\n\n    return this;\n  },\n  dropTimestamps: function dropTimestamps() {\n    return this.dropColumns(['created_at', 'updated_at']);\n  }\n}; // Drop a column from the current table.\n// TODO: Enable this.column(columnName).drop();\n\nAlterMethods.dropColumn = AlterMethods.dropColumns = function () {\n  this._statements.push({\n    grouping: 'alterTable',\n    method: 'dropColumn',\n    args: (0, _lodash.toArray)(arguments)\n  });\n\n  return this;\n};\n\nvar _default = TableBuilder;\nexports.default = _default;\nmodule.exports = exports.default;","map":null,"metadata":{},"sourceType":"script"}