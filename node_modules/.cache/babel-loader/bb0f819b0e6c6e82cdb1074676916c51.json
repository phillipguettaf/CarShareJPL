{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _inherits = _interopRequireDefault(require(\"inherits\"));\n\nvar _compiler = _interopRequireDefault(require(\"../../../query/compiler\"));\n\nvar _lodash = require(\"lodash\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // SQLite3 Query Builder & Compiler\n\n\nfunction QueryCompiler_SQLite3(client, builder) {\n  _compiler.default.call(this, client, builder);\n\n  var returning = this.single.returning;\n\n  if (returning) {\n    this.client.logger.warn('.returning() is not supported by sqlite3 and will not have any effect.');\n  }\n}\n\n(0, _inherits.default)(QueryCompiler_SQLite3, _compiler.default);\n(0, _lodash.assign)(QueryCompiler_SQLite3.prototype, {\n  // The locks are not applicable in SQLite3\n  forShare: emptyStr,\n  forUpdate: emptyStr,\n  // SQLite requires us to build the multi-row insert as a listing of select with\n  // unions joining them together. So we'll build out this list of columns and\n  // then join them all together with select unions to complete the queries.\n  insert: function insert() {\n    var insertValues = this.single.insert || [];\n    var sql = this.with() + \"insert into \".concat(this.tableName, \" \");\n\n    if (Array.isArray(insertValues)) {\n      if (insertValues.length === 0) {\n        return '';\n      } else if (insertValues.length === 1 && insertValues[0] && (0, _lodash.isEmpty)(insertValues[0])) {\n        return sql + this._emptyInsertValue;\n      }\n    } else if (typeof insertValues === 'object' && (0, _lodash.isEmpty)(insertValues)) {\n      return sql + this._emptyInsertValue;\n    }\n\n    var insertData = this._prepInsert(insertValues);\n\n    if ((0, _lodash.isString)(insertData)) {\n      return sql + insertData;\n    }\n\n    if (insertData.columns.length === 0) {\n      return '';\n    }\n\n    sql += \"(\".concat(this.formatter.columnize(insertData.columns), \")\"); // backwards compatible error\n\n    if (this.client.valueForUndefined !== null) {\n      (0, _lodash.each)(insertData.values, function (bindings) {\n        (0, _lodash.each)(bindings, function (binding) {\n          if (binding === undefined) throw new TypeError('`sqlite` does not support inserting default values. Specify ' + 'values explicitly or use the `useNullAsDefault` config flag. ' + '(see docs http://knexjs.org/#Builder-insert).');\n        });\n      });\n    }\n\n    if (insertData.values.length === 1) {\n      var parameters = this.formatter.parameterize(insertData.values[0], this.client.valueForUndefined);\n      return sql + \" values (\".concat(parameters, \")\");\n    }\n\n    var blocks = [];\n    var i = -1;\n\n    while (++i < insertData.values.length) {\n      var i2 = -1;\n      var block = blocks[i] = [];\n      var current = insertData.values[i];\n      current = current === undefined ? this.client.valueForUndefined : current;\n\n      while (++i2 < insertData.columns.length) {\n        block.push(this.formatter.alias(this.formatter.parameter(current[i2]), this.formatter.wrap(insertData.columns[i2])));\n      }\n\n      blocks[i] = block.join(', ');\n    }\n\n    return sql + ' select ' + blocks.join(' union all select ');\n  },\n  // Compile a truncate table statement into SQL.\n  truncate: function truncate() {\n    var table = this.single.table;\n    return {\n      sql: \"delete from \".concat(this.tableName),\n      output: function output() {\n        return this.query({\n          sql: \"delete from sqlite_sequence where name = '\".concat(table, \"'\")\n        }).catch(_lodash.noop);\n      }\n    };\n  },\n  // Compiles a `columnInfo` query\n  columnInfo: function columnInfo() {\n    var column = this.single.columnInfo; // The user may have specified a custom wrapIdentifier function in the config. We\n    // need to run the identifiers through that function, but not format them as\n    // identifiers otherwise.\n\n    var table = this.client.customWrapIdentifier(this.single.table, _lodash.identity);\n    return {\n      sql: \"PRAGMA table_info(`\".concat(table, \"`)\"),\n      output: function output(resp) {\n        var maxLengthRegex = /.*\\((\\d+)\\)/;\n        var out = (0, _lodash.reduce)(resp, function (columns, val) {\n          var type = val.type;\n          var maxLength = type.match(maxLengthRegex);\n\n          if (maxLength) {\n            maxLength = maxLength[1];\n          }\n\n          type = maxLength ? type.split('(')[0] : type;\n          columns[val.name] = {\n            type: type.toLowerCase(),\n            maxLength: maxLength,\n            nullable: !val.notnull,\n            defaultValue: val.dflt_value\n          };\n          return columns;\n        }, {});\n        return column && out[column] || out;\n      }\n    };\n  },\n  limit: function limit() {\n    var noLimit = !this.single.limit && this.single.limit !== 0;\n    if (noLimit && !this.single.offset) return ''; // Workaround for offset only,\n    // see http://stackoverflow.com/questions/10491492/sqllite-with-skip-offset-only-not-limit\n\n    return \"limit \".concat(this.formatter.parameter(noLimit ? -1 : this.single.limit));\n  }\n});\n\nfunction emptyStr() {\n  return '';\n}\n\nvar _default = QueryCompiler_SQLite3;\nexports.default = _default;\nmodule.exports = exports.default;","map":null,"metadata":{},"sourceType":"script"}