{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _inherits = _interopRequireDefault(require(\"inherits\"));\n\nvar _tablecompiler = _interopRequireDefault(require(\"../../../schema/tablecompiler\"));\n\nvar _lodash = require(\"lodash\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // Table Compiler\n// -------\n\n\nfunction TableCompiler_SQLite3() {\n  _tablecompiler.default.apply(this, arguments);\n\n  this.primaryKey = void 0;\n}\n\n(0, _inherits.default)(TableCompiler_SQLite3, _tablecompiler.default); // Create a new table.\n\nTableCompiler_SQLite3.prototype.createQuery = function (columns, ifNot) {\n  var createStatement = ifNot ? 'create table if not exists ' : 'create table ';\n  var sql = createStatement + this.tableName() + ' (' + columns.sql.join(', '); // SQLite forces primary keys to be added when the table is initially created\n  // so we will need to check for a primary key commands and add the columns\n  // to the table's declaration here so they can be created on the tables.\n\n  sql += this.foreignKeys() || '';\n  sql += this.primaryKeys() || '';\n  sql += ')';\n  this.pushQuery(sql);\n};\n\nTableCompiler_SQLite3.prototype.addColumns = function (columns, prefix) {\n  if (prefix) {\n    throw new Error('Sqlite does not support alter column.');\n  }\n\n  for (var i = 0, l = columns.sql.length; i < l; i++) {\n    this.pushQuery({\n      sql: \"alter table \".concat(this.tableName(), \" add column \").concat(columns.sql[i]),\n      bindings: columns.bindings[i]\n    });\n  }\n}; // Compile a drop unique key command.\n\n\nTableCompiler_SQLite3.prototype.dropUnique = function (columns, indexName) {\n  indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('unique', this.tableNameRaw, columns);\n  this.pushQuery(\"drop index \".concat(indexName));\n};\n\nTableCompiler_SQLite3.prototype.dropIndex = function (columns, indexName) {\n  indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('index', this.tableNameRaw, columns);\n  this.pushQuery(\"drop index \".concat(indexName));\n}; // Compile a unique key command.\n\n\nTableCompiler_SQLite3.prototype.unique = function (columns, indexName) {\n  indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('unique', this.tableNameRaw, columns);\n  columns = this.formatter.columnize(columns);\n  this.pushQuery(\"create unique index \".concat(indexName, \" on \").concat(this.tableName(), \" (\").concat(columns, \")\"));\n}; // Compile a plain index key command.\n\n\nTableCompiler_SQLite3.prototype.index = function (columns, indexName) {\n  indexName = indexName ? this.formatter.wrap(indexName) : this._indexCommand('index', this.tableNameRaw, columns);\n  columns = this.formatter.columnize(columns);\n  this.pushQuery(\"create index \".concat(indexName, \" on \").concat(this.tableName(), \" (\").concat(columns, \")\"));\n};\n\nTableCompiler_SQLite3.prototype.primary = TableCompiler_SQLite3.prototype.foreign = function () {\n  if (this.method !== 'create' && this.method !== 'createIfNot') {\n    this.client.logger.warn('SQLite3 Foreign & Primary keys may only be added on create');\n  }\n};\n\nTableCompiler_SQLite3.prototype.primaryKeys = function () {\n  var pks = (0, _lodash.filter)(this.grouped.alterTable || [], {\n    method: 'primary'\n  });\n\n  if (pks.length > 0 && pks[0].args.length > 0) {\n    var columns = pks[0].args[0];\n    var constraintName = pks[0].args[1] || '';\n\n    if (constraintName) {\n      constraintName = ' constraint ' + this.formatter.wrap(constraintName);\n    }\n\n    return \",\".concat(constraintName, \" primary key (\").concat(this.formatter.columnize(columns), \")\");\n  }\n};\n\nTableCompiler_SQLite3.prototype.foreignKeys = function () {\n  var sql = '';\n  var foreignKeys = (0, _lodash.filter)(this.grouped.alterTable || [], {\n    method: 'foreign'\n  });\n\n  for (var i = 0, l = foreignKeys.length; i < l; i++) {\n    var foreign = foreignKeys[i].args[0];\n    var column = this.formatter.columnize(foreign.column);\n    var references = this.formatter.columnize(foreign.references);\n    var foreignTable = this.formatter.wrap(foreign.inTable);\n    var constraintName = foreign.keyName || '';\n\n    if (constraintName) {\n      constraintName = ' constraint ' + this.formatter.wrap(constraintName);\n    }\n\n    sql += \",\".concat(constraintName, \" foreign key(\").concat(column, \") references \").concat(foreignTable, \"(\").concat(references, \")\");\n    if (foreign.onDelete) sql += \" on delete \".concat(foreign.onDelete);\n    if (foreign.onUpdate) sql += \" on update \".concat(foreign.onUpdate);\n  }\n\n  return sql;\n};\n\nTableCompiler_SQLite3.prototype.createTableBlock = function () {\n  return this.getColumns().concat().join(',');\n}; // Compile a rename column command... very complex in sqlite\n\n\nTableCompiler_SQLite3.prototype.renameColumn = function (from, to) {\n  var compiler = this;\n  this.pushQuery({\n    sql: \"PRAGMA table_info(\".concat(this.tableName(), \")\"),\n    output: function output(pragma) {\n      return compiler.client.ddl(compiler, pragma, this.connection).renameColumn(from, to);\n    }\n  });\n};\n\nTableCompiler_SQLite3.prototype.dropColumn = function () {\n  var compiler = this;\n  var columns = (0, _lodash.values)(arguments);\n  this.pushQuery({\n    sql: \"PRAGMA table_info(\".concat(this.tableName(), \")\"),\n    output: function output(pragma) {\n      return compiler.client.ddl(compiler, pragma, this.connection).dropColumn(columns);\n    }\n  });\n};\n\nvar _default = TableCompiler_SQLite3;\nexports.default = _default;\nmodule.exports = exports.default;","map":null,"metadata":{},"sourceType":"script"}