{"ast":null,"code":"\"use strict\";\n\nvar _ = require('lodash');\n\nvar inherits = require('inherits');\n\nvar Oracle_Compiler = require('../../oracle/query/compiler');\n\nvar ReturningHelper = require('../utils').ReturningHelper;\n\nvar BlobHelper = require('../utils').BlobHelper;\n\nfunction Oracledb_Compiler(client, builder) {\n  Oracle_Compiler.call(this, client, builder);\n}\n\ninherits(Oracledb_Compiler, Oracle_Compiler);\n\n_.assign(Oracledb_Compiler.prototype, {\n  // Compiles an \"insert\" query, allowing for multiple\n  // inserts using a single query statement.\n  insert: function insert() {\n    var self = this;\n\n    var outBindPrep = this._prepOutbindings(this.single.insert, this.single.returning);\n\n    var outBinding = outBindPrep.outBinding;\n    var returning = outBindPrep.returning;\n    var insertValues = outBindPrep.values;\n\n    if (Array.isArray(insertValues) && insertValues.length === 1 && _.isEmpty(insertValues[0])) {\n      return this._addReturningToSqlAndConvert('insert into ' + this.tableName + ' (' + this.formatter.wrap(this.single.returning) + ') values (default)', outBinding[0], this.tableName, returning);\n    }\n\n    if (_.isEmpty(this.single.insert) && typeof this.single.insert !== 'function') {\n      return '';\n    }\n\n    var insertData = this._prepInsert(insertValues);\n\n    var sql = {};\n\n    if (_.isString(insertData)) {\n      return this._addReturningToSqlAndConvert('insert into ' + this.tableName + ' ' + insertData, outBinding[0], this.tableName, returning);\n    }\n\n    if (insertData.values.length === 1) {\n      return this._addReturningToSqlAndConvert('insert into ' + this.tableName + ' (' + this.formatter.columnize(insertData.columns) + ') values (' + this.formatter.parameterize(insertData.values[0]) + ')', outBinding[0], this.tableName, returning);\n    }\n\n    var insertDefaultsOnly = insertData.columns.length === 0;\n    sql.returning = returning;\n    sql.sql = 'begin ' + _.map(insertData.values, function (value, index) {\n      var parameterizedValues = !insertDefaultsOnly ? self.formatter.parameterize(value, self.client.valueForUndefined) : '';\n      var subSql = 'insert into ' + self.tableName;\n\n      if (insertDefaultsOnly) {\n        // No columns given so only the default value\n        subSql += ' (' + self.formatter.wrap(self.single.returning) + ') values (default)';\n      } else {\n        subSql += ' (' + self.formatter.columnize(insertData.columns) + ') values (' + parameterizedValues + ')';\n      }\n\n      var returningClause = '';\n      var intoClause = ''; // ToDo review if this code is still needed or could be dropped\n      // eslint-disable-next-line no-unused-vars\n\n      var usingClause = '';\n      var outClause = '';\n\n      _.each(value, function (val) {\n        if (!(val instanceof BlobHelper)) {\n          usingClause += ' ?,';\n        }\n      });\n\n      usingClause = usingClause.slice(0, -1); // Build returning and into clauses\n\n      _.each(outBinding[index], function (ret) {\n        var columnName = ret.columnName || ret;\n        returningClause += self.formatter.wrap(columnName) + ',';\n        intoClause += ' ?,';\n        outClause += ' out ?,'; // Add Helpers to bindings\n\n        if (ret instanceof BlobHelper) {\n          return self.formatter.bindings.push(ret);\n        }\n\n        self.formatter.bindings.push(new ReturningHelper(columnName));\n      }); // Strip last comma\n\n\n      returningClause = returningClause.slice(0, -1);\n      intoClause = intoClause.slice(0, -1);\n      outClause = outClause.slice(0, -1);\n\n      if (returningClause && intoClause) {\n        subSql += ' returning ' + returningClause + ' into' + intoClause;\n      } // Pre bind position because subSql is an execute immediate parameter\n      // later position binding will only convert the ? params\n\n\n      subSql = self.formatter.client.positionBindings(subSql);\n      var parameterizedValuesWithoutDefaultAndBlob = parameterizedValues.replace('DEFAULT, ', '').replace(', DEFAULT', '').replace('EMPTY_BLOB(), ', '').replace(', EMPTY_BLOB()', '');\n      return \"execute immediate '\" + subSql.replace(/'/g, \"''\") + (parameterizedValuesWithoutDefaultAndBlob || value ? \"' using \" : '') + parameterizedValuesWithoutDefaultAndBlob + (parameterizedValuesWithoutDefaultAndBlob && outClause ? ',' : '') + outClause + ';';\n    }).join(' ') + 'end;';\n    sql.outBinding = outBinding;\n\n    if (returning[0] === '*') {\n      // Generate select statement with special order by\n      // to keep the order because 'in (..)' may change the order\n      sql.returningSql = function () {\n        return 'select * from ' + self.tableName + ' where ROWID in (' + this.outBinding.map(function (v, i) {\n          return ':' + (i + 1);\n        }).join(', ') + ')' + ' order by case ROWID ' + this.outBinding.map(function (v, i) {\n          return 'when CHARTOROWID(:' + (i + 1) + ') then ' + i;\n        }).join(' ') + ' end';\n      };\n    }\n\n    return sql;\n  },\n  _addReturningToSqlAndConvert: function _addReturningToSqlAndConvert(sql, outBinding, tableName, returning) {\n    var self = this;\n    var res = {\n      sql: sql\n    };\n\n    if (!outBinding) {\n      return res;\n    }\n\n    var returningValues = Array.isArray(outBinding) ? outBinding : [outBinding];\n    var returningClause = '';\n    var intoClause = ''; // Build returning and into clauses\n\n    _.each(returningValues, function (ret) {\n      var columnName = ret.columnName || ret;\n      returningClause += self.formatter.wrap(columnName) + ',';\n      intoClause += '?,'; // Add Helpers to bindings\n\n      if (ret instanceof BlobHelper) {\n        return self.formatter.bindings.push(ret);\n      }\n\n      self.formatter.bindings.push(new ReturningHelper(columnName));\n    });\n\n    res.sql = sql; // Strip last comma\n\n    returningClause = returningClause.slice(0, -1);\n    intoClause = intoClause.slice(0, -1);\n\n    if (returningClause && intoClause) {\n      res.sql += ' returning ' + returningClause + ' into ' + intoClause;\n    }\n\n    res.outBinding = [outBinding];\n\n    if (returning[0] === '*') {\n      res.returningSql = function () {\n        return 'select * from ' + self.tableName + ' where ROWID = :1';\n      };\n    }\n\n    res.returning = returning;\n    return res;\n  },\n  _prepOutbindings: function _prepOutbindings(paramValues, paramReturning) {\n    var result = {};\n    var params = paramValues || [];\n    var returning = paramReturning || [];\n\n    if (!Array.isArray(params) && _.isPlainObject(paramValues)) {\n      params = [params];\n    } // Always wrap returning argument in array\n\n\n    if (returning && !Array.isArray(returning)) {\n      returning = [returning];\n    }\n\n    var outBinding = []; // Handle Buffer value as Blob\n\n    _.each(params, function (values, index) {\n      if (returning[0] === '*') {\n        outBinding[index] = ['ROWID'];\n      } else {\n        outBinding[index] = _.clone(returning);\n      }\n\n      _.each(values, function (value, key) {\n        if (value instanceof Buffer) {\n          values[key] = new BlobHelper(key, value); // Delete blob duplicate in returning\n\n          var blobIndex = outBinding[index].indexOf(key);\n\n          if (blobIndex >= 0) {\n            outBinding[index].splice(blobIndex, 1);\n            values[key].returning = true;\n          }\n\n          outBinding[index].push(values[key]);\n        }\n\n        if (_.isUndefined(value)) {\n          delete params[index][key];\n        }\n      });\n    });\n\n    result.returning = returning;\n    result.outBinding = outBinding;\n    result.values = params;\n    return result;\n  },\n  update: function update() {\n    var self = this;\n    var sql = {};\n\n    var outBindPrep = this._prepOutbindings(this.single.update || this.single.counter, this.single.returning);\n\n    var outBinding = outBindPrep.outBinding;\n    var returning = outBindPrep.returning;\n\n    var updates = this._prepUpdate(this.single.update);\n\n    var where = this.where();\n    var returningClause = '';\n    var intoClause = '';\n\n    if (_.isEmpty(updates) && typeof this.single.update !== 'function') {\n      return '';\n    } // Build returning and into clauses\n\n\n    _.each(outBinding, function (out) {\n      _.each(out, function (ret) {\n        var columnName = ret.columnName || ret;\n        returningClause += self.formatter.wrap(columnName) + ',';\n        intoClause += ' ?,'; // Add Helpers to bindings\n\n        if (ret instanceof BlobHelper) {\n          return self.formatter.bindings.push(ret);\n        }\n\n        self.formatter.bindings.push(new ReturningHelper(columnName));\n      });\n    }); // Strip last comma\n\n\n    returningClause = returningClause.slice(0, -1);\n    intoClause = intoClause.slice(0, -1);\n    sql.outBinding = outBinding;\n    sql.returning = returning;\n    sql.sql = 'update ' + this.tableName + ' set ' + updates.join(', ') + (where ? ' ' + where : '');\n\n    if (outBinding.length && !_.isEmpty(outBinding[0])) {\n      sql.sql += ' returning ' + returningClause + ' into' + intoClause;\n    }\n\n    if (returning[0] === '*') {\n      sql.returningSql = function () {\n        var sql = 'select * from ' + self.tableName;\n        var modifiedRowsCount = this.rowsAffected.length || this.rowsAffected;\n        var returningSqlIn = ' where ROWID in (';\n        var returningSqlOrderBy = ') order by case ROWID '; // Needs special order by because in(...) change result order\n\n        for (var i = 0; i < modifiedRowsCount; i++) {\n          if (this.returning[0] === '*') {\n            returningSqlIn += ':' + (i + 1) + ', ';\n            returningSqlOrderBy += 'when CHARTOROWID(:' + (i + 1) + ') then ' + i + ' ';\n          }\n        }\n\n        if (this.returning[0] === '*') {\n          this.returning = this.returning.slice(0, -1);\n          returningSqlIn = returningSqlIn.slice(0, -2);\n          returningSqlOrderBy = returningSqlOrderBy.slice(0, -1);\n        }\n\n        return sql += returningSqlIn + returningSqlOrderBy + ' end';\n      };\n    }\n\n    return sql;\n  }\n});\n\nmodule.exports = Oracledb_Compiler;","map":null,"metadata":{},"sourceType":"script"}