{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _assert = _interopRequireDefault(require(\"assert\"));\n\nvar _inherits = _interopRequireDefault(require(\"inherits\"));\n\nvar _events = require(\"events\");\n\nvar _raw = _interopRequireDefault(require(\"../raw\"));\n\nvar helpers = _interopRequireWildcard(require(\"../helpers\"));\n\nvar _joinclause = _interopRequireDefault(require(\"./joinclause\"));\n\nvar _lodash = require(\"lodash\");\n\nvar _saveAsyncStack = _interopRequireDefault(require(\"../util/save-async-stack\"));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // Builder\n// -------\n// Typically called from `knex.builder`,\n// start a new query building chain.\n\n\nfunction Builder(client) {\n  this.client = client;\n  this.and = this;\n  this._single = {};\n  this._statements = [];\n  this._method = 'select';\n\n  if (client.config) {\n    (0, _saveAsyncStack.default)(this, 5);\n    this._debug = client.config.debug;\n  } // Internal flags used in the builder.\n\n\n  this._joinFlag = 'inner';\n  this._boolFlag = 'and';\n  this._notFlag = false;\n  this._asColumnFlag = false;\n}\n\n(0, _inherits.default)(Builder, _events.EventEmitter);\n\nvar validateWithArgs = function validateWithArgs(alias, statement, method) {\n  if (typeof alias !== 'string') {\n    throw new Error(\"\".concat(method, \"() first argument must be a string\"));\n  }\n\n  if (typeof statement === 'function' || statement instanceof Builder || statement instanceof _raw.default) {\n    return;\n  }\n\n  throw new Error(\"\".concat(method, \"() second argument must be a function / QueryBuilder or a raw\"));\n};\n\n(0, _lodash.assign)(Builder.prototype, {\n  toString: function toString() {\n    return this.toQuery();\n  },\n  // Convert the current query \"toSQL\"\n  toSQL: function toSQL(method, tz) {\n    return this.client.queryCompiler(this).toSQL(method || this._method, tz);\n  },\n  // Create a shallow clone of the current query builder.\n  clone: function clone() {\n    var cloned = new this.constructor(this.client);\n    cloned._method = this._method;\n    cloned._single = (0, _lodash.clone)(this._single);\n    cloned._statements = (0, _lodash.clone)(this._statements);\n    cloned._debug = this._debug; // `_option` is assigned by the `Interface` mixin.\n\n    if (!(0, _lodash.isUndefined)(this._options)) {\n      cloned._options = (0, _lodash.clone)(this._options);\n    }\n\n    if (!(0, _lodash.isUndefined)(this._queryContext)) {\n      cloned._queryContext = (0, _lodash.clone)(this._queryContext);\n    }\n\n    if (!(0, _lodash.isUndefined)(this._connection)) {\n      cloned._connection = this._connection;\n    }\n\n    return cloned;\n  },\n  timeout: function timeout(ms) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        cancel = _ref.cancel;\n\n    if ((0, _lodash.isNumber)(ms) && ms > 0) {\n      this._timeout = ms;\n\n      if (cancel) {\n        this.client.assertCanCancelQuery();\n        this._cancelOnTimeout = true;\n      }\n    }\n\n    return this;\n  },\n  // With\n  // ------\n  with: function _with(alias, statement) {\n    validateWithArgs(alias, statement, 'with');\n    return this.withWrapped(alias, statement);\n  },\n  // Helper for compiling any advanced `with` queries.\n  withWrapped: function withWrapped(alias, query) {\n    this._statements.push({\n      grouping: 'with',\n      type: 'withWrapped',\n      alias: alias,\n      value: query\n    });\n\n    return this;\n  },\n  // With Recursive\n  // ------\n  withRecursive: function withRecursive(alias, statement) {\n    validateWithArgs(alias, statement, 'withRecursive');\n    return this.withRecursiveWrapped(alias, statement);\n  },\n  // Helper for compiling any advanced `withRecursive` queries.\n  withRecursiveWrapped: function withRecursiveWrapped(alias, query) {\n    this.withWrapped(alias, query);\n    this._statements[this._statements.length - 1].recursive = true;\n    return this;\n  },\n  // Select\n  // ------\n  // Adds a column or columns to the list of \"columns\"\n  // being selected on the query.\n  columns: function columns(column) {\n    if (!column && column !== 0) return this;\n\n    this._statements.push({\n      grouping: 'columns',\n      value: helpers.normalizeArr.apply(null, arguments)\n    });\n\n    return this;\n  },\n  // Allow for a sub-select to be explicitly aliased as a column,\n  // without needing to compile the query in a where.\n  as: function as(column) {\n    this._single.as = column;\n    return this;\n  },\n  // Prepends the `schemaName` on `tableName` defined by `.table` and `.join`.\n  withSchema: function withSchema(schemaName) {\n    this._single.schema = schemaName;\n    return this;\n  },\n  // Sets the `tableName` on the query.\n  // Alias to \"from\" for select and \"into\" for insert statements\n  // e.g. builder.insert({a: value}).into('tableName')\n  // `options`: options object containing keys:\n  //   - `only`: whether the query should use SQL's ONLY to not return\n  //           inheriting table data. Defaults to false.\n  table: function table(tableName) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this._single.table = tableName;\n    this._single.only = options.only === true;\n    return this;\n  },\n  // Adds a `distinct` clause to the query.\n  distinct: function distinct() {\n    this._statements.push({\n      grouping: 'columns',\n      value: helpers.normalizeArr.apply(null, arguments),\n      distinct: true\n    });\n\n    return this;\n  },\n  // Adds a join clause to the query, allowing for advanced joins\n  // with an anonymous function as the second argument.\n  // function(table, first, operator, second)\n  join: function join(table, first) {\n    var join;\n    var schema = this._single.schema;\n\n    var joinType = this._joinType();\n\n    if (typeof first === 'function') {\n      join = new _joinclause.default(table, joinType, schema);\n      first.call(join, join);\n    } else if (joinType === 'raw') {\n      join = new _joinclause.default(this.client.raw(table, first), 'raw');\n    } else {\n      join = new _joinclause.default(table, joinType, table instanceof Builder ? undefined : schema);\n\n      if (arguments.length > 1) {\n        join.on.apply(join, (0, _lodash.toArray)(arguments).slice(1));\n      }\n    }\n\n    this._statements.push(join);\n\n    return this;\n  },\n  // JOIN blocks:\n  innerJoin: function innerJoin() {\n    return this._joinType('inner').join.apply(this, arguments);\n  },\n  leftJoin: function leftJoin() {\n    return this._joinType('left').join.apply(this, arguments);\n  },\n  leftOuterJoin: function leftOuterJoin() {\n    return this._joinType('left outer').join.apply(this, arguments);\n  },\n  rightJoin: function rightJoin() {\n    return this._joinType('right').join.apply(this, arguments);\n  },\n  rightOuterJoin: function rightOuterJoin() {\n    return this._joinType('right outer').join.apply(this, arguments);\n  },\n  outerJoin: function outerJoin() {\n    return this._joinType('outer').join.apply(this, arguments);\n  },\n  fullOuterJoin: function fullOuterJoin() {\n    return this._joinType('full outer').join.apply(this, arguments);\n  },\n  crossJoin: function crossJoin() {\n    return this._joinType('cross').join.apply(this, arguments);\n  },\n  joinRaw: function joinRaw() {\n    return this._joinType('raw').join.apply(this, arguments);\n  },\n  // The where function can be used in several ways:\n  // The most basic is `where(key, value)`, which expands to\n  // where key = value.\n  where: function where(column, operator, value) {\n    // Support \"where true || where false\"\n    if (column === false || column === true) {\n      return this.where(1, '=', column ? 1 : 0);\n    } // Check if the column is a function, in which case it's\n    // a where statement wrapped in parens.\n\n\n    if (typeof column === 'function') {\n      return this.whereWrapped(column);\n    } // Allow a raw statement to be passed along to the query.\n\n\n    if (column instanceof _raw.default && arguments.length === 1) return this.whereRaw(column); // Allows `where({id: 2})` syntax.\n\n    if ((0, _lodash.isObject)(column) && !(column instanceof _raw.default)) return this._objectWhere(column); // Enable the where('key', value) syntax, only when there\n    // are explicitly two arguments passed, so it's not possible to\n    // do where('key', '!=') and have that turn into where key != null\n\n    if (arguments.length === 2) {\n      value = operator;\n      operator = '='; // If the value is null, and it's a two argument query,\n      // we assume we're going for a `whereNull`.\n\n      if (value === null) {\n        return this.whereNull(column);\n      }\n    } // lower case the operator for comparison purposes\n\n\n    var checkOperator = \"\".concat(operator).toLowerCase().trim(); // If there are 3 arguments, check whether 'in' is one of them.\n\n    if (arguments.length === 3) {\n      if (checkOperator === 'in' || checkOperator === 'not in') {\n        return this._not(checkOperator === 'not in').whereIn(arguments[0], arguments[2]);\n      }\n\n      if (checkOperator === 'between' || checkOperator === 'not between') {\n        return this._not(checkOperator === 'not between').whereBetween(arguments[0], arguments[2]);\n      }\n    } // If the value is still null, check whether they're meaning\n    // where value is null\n\n\n    if (value === null) {\n      // Check for .where(key, 'is', null) or .where(key, 'is not', 'null');\n      if (checkOperator === 'is' || checkOperator === 'is not') {\n        return this._not(checkOperator === 'is not').whereNull(column);\n      }\n    } // Push onto the where statement stack.\n\n\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereBasic',\n      column: column,\n      operator: operator,\n      value: value,\n      not: this._not(),\n      bool: this._bool(),\n      asColumn: this._asColumnFlag\n    });\n\n    return this;\n  },\n  whereColumn: function whereColumn(column, operator, rightColumn) {\n    this._asColumnFlag = true;\n    this.where.apply(this, arguments);\n    this._asColumnFlag = false;\n    return this;\n  },\n  // Adds an `or where` clause to the query.\n  orWhere: function orWhere() {\n    this._bool('or');\n\n    var obj = arguments[0];\n\n    if ((0, _lodash.isObject)(obj) && !(0, _lodash.isFunction)(obj) && !(obj instanceof _raw.default)) {\n      return this.whereWrapped(function () {\n        for (var key in obj) {\n          this.andWhere(key, obj[key]);\n        }\n      });\n    }\n\n    return this.where.apply(this, arguments);\n  },\n  orWhereColumn: function orWhereColumn() {\n    this._bool('or');\n\n    var obj = arguments[0];\n\n    if ((0, _lodash.isObject)(obj) && !(0, _lodash.isFunction)(obj) && !(obj instanceof _raw.default)) {\n      return this.whereWrapped(function () {\n        for (var key in obj) {\n          this.andWhereColumn(key, '=', obj[key]);\n        }\n      });\n    }\n\n    return this.whereColumn.apply(this, arguments);\n  },\n  // Adds an `not where` clause to the query.\n  whereNot: function whereNot() {\n    return this._not(true).where.apply(this, arguments);\n  },\n  whereNotColumn: function whereNotColumn() {\n    return this._not(true).whereColumn.apply(this, arguments);\n  },\n  // Adds an `or not where` clause to the query.\n  orWhereNot: function orWhereNot() {\n    return this._bool('or').whereNot.apply(this, arguments);\n  },\n  orWhereNotColumn: function orWhereNotColumn() {\n    return this._bool('or').whereNotColumn.apply(this, arguments);\n  },\n  // Processes an object literal provided in a \"where\" clause.\n  _objectWhere: function _objectWhere(obj) {\n    var boolVal = this._bool();\n\n    var notVal = this._not() ? 'Not' : '';\n\n    for (var key in obj) {\n      this[boolVal + 'Where' + notVal](key, obj[key]);\n    }\n\n    return this;\n  },\n  // Adds a raw `where` clause to the query.\n  whereRaw: function whereRaw(sql, bindings) {\n    var raw = sql instanceof _raw.default ? sql : this.client.raw(sql, bindings);\n\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereRaw',\n      value: raw,\n      not: this._not(),\n      bool: this._bool()\n    });\n\n    return this;\n  },\n  orWhereRaw: function orWhereRaw(sql, bindings) {\n    return this._bool('or').whereRaw(sql, bindings);\n  },\n  // Helper for compiling any advanced `where` queries.\n  whereWrapped: function whereWrapped(callback) {\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereWrapped',\n      value: callback,\n      not: this._not(),\n      bool: this._bool()\n    });\n\n    return this;\n  },\n  // Adds a `where exists` clause to the query.\n  whereExists: function whereExists(callback) {\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereExists',\n      value: callback,\n      not: this._not(),\n      bool: this._bool()\n    });\n\n    return this;\n  },\n  // Adds an `or where exists` clause to the query.\n  orWhereExists: function orWhereExists(callback) {\n    return this._bool('or').whereExists(callback);\n  },\n  // Adds a `where not exists` clause to the query.\n  whereNotExists: function whereNotExists(callback) {\n    return this._not(true).whereExists(callback);\n  },\n  // Adds a `or where not exists` clause to the query.\n  orWhereNotExists: function orWhereNotExists(callback) {\n    return this._bool('or').whereNotExists(callback);\n  },\n  // Adds a `where in` clause to the query.\n  whereIn: function whereIn(column, values) {\n    if (Array.isArray(values) && (0, _lodash.isEmpty)(values)) return this.where(this._not());\n\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereIn',\n      column: column,\n      value: values,\n      not: this._not(),\n      bool: this._bool()\n    });\n\n    return this;\n  },\n  // Adds a `or where in` clause to the query.\n  orWhereIn: function orWhereIn(column, values) {\n    return this._bool('or').whereIn(column, values);\n  },\n  // Adds a `where not in` clause to the query.\n  whereNotIn: function whereNotIn(column, values) {\n    return this._not(true).whereIn(column, values);\n  },\n  // Adds a `or where not in` clause to the query.\n  orWhereNotIn: function orWhereNotIn(column, values) {\n    return this._bool('or')._not(true).whereIn(column, values);\n  },\n  // Adds a `where null` clause to the query.\n  whereNull: function whereNull(column) {\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereNull',\n      column: column,\n      not: this._not(),\n      bool: this._bool()\n    });\n\n    return this;\n  },\n  // Adds a `or where null` clause to the query.\n  orWhereNull: function orWhereNull(column) {\n    return this._bool('or').whereNull(column);\n  },\n  // Adds a `where not null` clause to the query.\n  whereNotNull: function whereNotNull(column) {\n    return this._not(true).whereNull(column);\n  },\n  // Adds a `or where not null` clause to the query.\n  orWhereNotNull: function orWhereNotNull(column) {\n    return this._bool('or').whereNotNull(column);\n  },\n  // Adds a `where between` clause to the query.\n  whereBetween: function whereBetween(column, values) {\n    (0, _assert.default)(Array.isArray(values), 'The second argument to whereBetween must be an array.');\n    (0, _assert.default)(values.length === 2, 'You must specify 2 values for the whereBetween clause');\n\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereBetween',\n      column: column,\n      value: values,\n      not: this._not(),\n      bool: this._bool()\n    });\n\n    return this;\n  },\n  // Adds a `where not between` clause to the query.\n  whereNotBetween: function whereNotBetween(column, values) {\n    return this._not(true).whereBetween(column, values);\n  },\n  // Adds a `or where between` clause to the query.\n  orWhereBetween: function orWhereBetween(column, values) {\n    return this._bool('or').whereBetween(column, values);\n  },\n  // Adds a `or where not between` clause to the query.\n  orWhereNotBetween: function orWhereNotBetween(column, values) {\n    return this._bool('or').whereNotBetween(column, values);\n  },\n  // Adds a `group by` clause to the query.\n  groupBy: function groupBy(item) {\n    if (item instanceof _raw.default) {\n      return this.groupByRaw.apply(this, arguments);\n    }\n\n    this._statements.push({\n      grouping: 'group',\n      type: 'groupByBasic',\n      value: helpers.normalizeArr.apply(null, arguments)\n    });\n\n    return this;\n  },\n  // Adds a raw `group by` clause to the query.\n  groupByRaw: function groupByRaw(sql, bindings) {\n    var raw = sql instanceof _raw.default ? sql : this.client.raw(sql, bindings);\n\n    this._statements.push({\n      grouping: 'group',\n      type: 'groupByRaw',\n      value: raw\n    });\n\n    return this;\n  },\n  // Adds a `order by` clause to the query.\n  orderBy: function orderBy(column, direction) {\n    if (Array.isArray(column)) {\n      return this._orderByArray(column);\n    }\n\n    this._statements.push({\n      grouping: 'order',\n      type: 'orderByBasic',\n      value: column,\n      direction: direction\n    });\n\n    return this;\n  },\n  // Adds a `order by` with multiple columns to the query.\n  _orderByArray: function _orderByArray(columnDefs) {\n    for (var i = 0; i < columnDefs.length; i++) {\n      var columnInfo = columnDefs[i];\n\n      if ((0, _lodash.isObject)(columnInfo)) {\n        this._statements.push({\n          grouping: 'order',\n          type: 'orderByBasic',\n          value: columnInfo['column'],\n          direction: columnInfo['order']\n        });\n      } else if ((0, _lodash.isString)(columnInfo)) {\n        this._statements.push({\n          grouping: 'order',\n          type: 'orderByBasic',\n          value: columnInfo\n        });\n      }\n    }\n\n    return this;\n  },\n  // Add a raw `order by` clause to the query.\n  orderByRaw: function orderByRaw(sql, bindings) {\n    var raw = sql instanceof _raw.default ? sql : this.client.raw(sql, bindings);\n\n    this._statements.push({\n      grouping: 'order',\n      type: 'orderByRaw',\n      value: raw\n    });\n\n    return this;\n  },\n  // Add a union statement to the query.\n  union: function union(callbacks, wrap) {\n    if (arguments.length === 1 || arguments.length === 2 && (0, _lodash.isBoolean)(wrap)) {\n      if (!Array.isArray(callbacks)) {\n        callbacks = [callbacks];\n      }\n\n      for (var i = 0, l = callbacks.length; i < l; i++) {\n        this._statements.push({\n          grouping: 'union',\n          clause: 'union',\n          value: callbacks[i],\n          wrap: wrap || false\n        });\n      }\n    } else {\n      callbacks = (0, _lodash.toArray)(arguments).slice(0, arguments.length - 1);\n      wrap = arguments[arguments.length - 1];\n\n      if (!(0, _lodash.isBoolean)(wrap)) {\n        callbacks.push(wrap);\n        wrap = false;\n      }\n\n      this.union(callbacks, wrap);\n    }\n\n    return this;\n  },\n  // Adds a union all statement to the query.\n  unionAll: function unionAll(callback, wrap) {\n    this._statements.push({\n      grouping: 'union',\n      clause: 'union all',\n      value: callback,\n      wrap: wrap || false\n    });\n\n    return this;\n  },\n  // Adds a `having` clause to the query.\n  having: function having(column, operator, value) {\n    if (column instanceof _raw.default && arguments.length === 1) {\n      return this.havingRaw(column);\n    } // Check if the column is a function, in which case it's\n    // a having statement wrapped in parens.\n\n\n    if (typeof column === 'function') {\n      return this.havingWrapped(column);\n    }\n\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingBasic',\n      column: column,\n      operator: operator,\n      value: value,\n      bool: this._bool(),\n      not: this._not()\n    });\n\n    return this;\n  },\n  orHaving: function orHaving() {\n    this._bool('or');\n\n    var obj = arguments[0];\n\n    if ((0, _lodash.isObject)(obj) && !(0, _lodash.isFunction)(obj) && !(obj instanceof _raw.default)) {\n      return this.havingWrapped(function () {\n        for (var key in obj) {\n          this.andHaving(key, obj[key]);\n        }\n      });\n    }\n\n    return this.having.apply(this, arguments);\n  },\n  // Helper for compiling any advanced `having` queries.\n  havingWrapped: function havingWrapped(callback) {\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingWrapped',\n      value: callback,\n      bool: this._bool(),\n      not: this._not()\n    });\n\n    return this;\n  },\n  havingNull: function havingNull(column) {\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingNull',\n      column: column,\n      not: this._not(),\n      bool: this._bool()\n    });\n\n    return this;\n  },\n  orHavingNull: function orHavingNull(callback) {\n    return this._bool('or').havingNull(callback);\n  },\n  havingNotNull: function havingNotNull(callback) {\n    return this._not(true).havingNull(callback);\n  },\n  orHavingNotNull: function orHavingNotNull(callback) {\n    return this._not(true)._bool('or').havingNull(callback);\n  },\n  havingExists: function havingExists(callback) {\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingExists',\n      value: callback,\n      not: this._not(),\n      bool: this._bool()\n    });\n\n    return this;\n  },\n  orHavingExists: function orHavingExists(callback) {\n    return this._bool('or').havingExists(callback);\n  },\n  havingNotExists: function havingNotExists(callback) {\n    return this._not(true).havingExists(callback);\n  },\n  orHavingNotExists: function orHavingNotExists(callback) {\n    return this._not(true)._bool('or').havingExists(callback);\n  },\n  havingBetween: function havingBetween(column, values) {\n    (0, _assert.default)(Array.isArray(values), 'The second argument to havingBetween must be an array.');\n    (0, _assert.default)(values.length === 2, 'You must specify 2 values for the havingBetween clause');\n\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingBetween',\n      column: column,\n      value: values,\n      not: this._not(),\n      bool: this._bool()\n    });\n\n    return this;\n  },\n  orHavingBetween: function orHavingBetween(column, values) {\n    return this._bool('or').havingBetween(column, values);\n  },\n  havingNotBetween: function havingNotBetween(column, values) {\n    return this._not(true).havingBetween(column, values);\n  },\n  orHavingNotBetween: function orHavingNotBetween(column, values) {\n    return this._not(true)._bool('or').havingBetween(column, values);\n  },\n  havingIn: function havingIn(column, values) {\n    if (Array.isArray(values) && (0, _lodash.isEmpty)(values)) return this.where(this._not());\n\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingIn',\n      column: column,\n      value: values,\n      not: this._not(),\n      bool: this._bool()\n    });\n\n    return this;\n  },\n  // Adds a `or where in` clause to the query.\n  orHavingIn: function orHavingIn(column, values) {\n    return this._bool('or').havingIn(column, values);\n  },\n  // Adds a `where not in` clause to the query.\n  havingNotIn: function havingNotIn(column, values) {\n    return this._not(true).havingIn(column, values);\n  },\n  // Adds a `or where not in` clause to the query.\n  orHavingNotIn: function orHavingNotIn(column, values) {\n    return this._bool('or')._not(true).havingIn(column, values);\n  },\n  // Adds a raw `having` clause to the query.\n  havingRaw: function havingRaw(sql, bindings) {\n    var raw = sql instanceof _raw.default ? sql : this.client.raw(sql, bindings);\n\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingRaw',\n      value: raw,\n      bool: this._bool(),\n      not: this._not()\n    });\n\n    return this;\n  },\n  orHavingRaw: function orHavingRaw(sql, bindings) {\n    return this._bool('or').havingRaw(sql, bindings);\n  },\n  // Only allow a single \"offset\" to be set for the current query.\n  offset: function offset(value) {\n    this._single.offset = value;\n    return this;\n  },\n  // Only allow a single \"limit\" to be set for the current query.\n  limit: function limit(value) {\n    var val = parseInt(value, 10);\n\n    if (isNaN(val)) {\n      this.client.logger.warn('A valid integer must be provided to limit');\n    } else {\n      this._single.limit = val;\n    }\n\n    return this;\n  },\n  // Retrieve the \"count\" result of the query.\n  count: function count(column) {\n    return this._aggregate('count', column || '*');\n  },\n  // Retrieve the minimum value of a given column.\n  min: function min(column) {\n    return this._aggregate('min', column);\n  },\n  // Retrieve the maximum value of a given column.\n  max: function max(column) {\n    return this._aggregate('max', column);\n  },\n  // Retrieve the sum of the values of a given column.\n  sum: function sum(column) {\n    return this._aggregate('sum', column);\n  },\n  // Retrieve the average of the values of a given column.\n  avg: function avg(column) {\n    return this._aggregate('avg', column);\n  },\n  // Retrieve the \"count\" of the distinct results of the query.\n  countDistinct: function countDistinct() {\n    var columns = helpers.normalizeArr.apply(null, arguments);\n\n    if (!columns.length) {\n      columns = '*';\n    } else if (columns.length === 1) {\n      columns = columns[0];\n    }\n\n    return this._aggregate('count', columns, true);\n  },\n  // Retrieve the sum of the distinct values of a given column.\n  sumDistinct: function sumDistinct(column) {\n    return this._aggregate('sum', column, true);\n  },\n  // Retrieve the vg of the distinct results of the query.\n  avgDistinct: function avgDistinct(column) {\n    return this._aggregate('avg', column, true);\n  },\n  // Increments a column's value by the specified amount.\n  increment: function increment(column) {\n    var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n    if ((0, _lodash.isObject)(column)) {\n      for (var key in column) {\n        this._counter(key, column[key]);\n      }\n\n      return this;\n    }\n\n    return this._counter(column, amount);\n  },\n  // Decrements a column's value by the specified amount.\n  decrement: function decrement(column) {\n    var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n    if ((0, _lodash.isObject)(column)) {\n      for (var key in column) {\n        this._counter(key, -column[key]);\n      }\n\n      return this;\n    }\n\n    return this._counter(column, -amount);\n  },\n  // Clears increments/decrements\n  clearCounters: function clearCounters() {\n    this._single.counter = {};\n    return this;\n  },\n  // Sets the values for a `select` query, informing that only the first\n  // row should be returned (limit 1).\n  first: function first() {\n    var _method = this._method;\n\n    if (!(0, _lodash.includes)(['pluck', 'first', 'select'], _method)) {\n      throw new Error(\"Cannot chain .first() on \\\"\".concat(_method, \"\\\" query!\"));\n    }\n\n    var args = new Array(arguments.length);\n\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    this.select.apply(this, args);\n    this._method = 'first';\n    this.limit(1);\n    return this;\n  },\n  // Use existing connection to execute the query\n  // Same value that client.acquireConnection() for an according client returns should be passed\n  connection: function connection(_connection) {\n    this._connection = _connection;\n    return this;\n  },\n  // Pluck a column from a query.\n  pluck: function pluck(column) {\n    this._method = 'pluck';\n    this._single.pluck = column;\n\n    this._statements.push({\n      grouping: 'columns',\n      type: 'pluck',\n      value: column\n    });\n\n    return this;\n  },\n  // Remove everything from select clause\n  clearSelect: function clearSelect() {\n    this._clearGrouping('columns');\n\n    return this;\n  },\n  // Remove everything from select clause\n  clearWhere: function clearWhere() {\n    this._clearGrouping('where');\n\n    return this;\n  },\n  // Remove everything from select clause\n  clearOrder: function clearOrder() {\n    this._clearGrouping('order');\n\n    return this;\n  },\n  // Insert & Update\n  // ------\n  // Sets the values for an `insert` query.\n  insert: function insert(values, returning) {\n    this._method = 'insert';\n    if (!(0, _lodash.isEmpty)(returning)) this.returning(returning);\n    this._single.insert = values;\n    return this;\n  },\n  // Sets the values for an `update`, allowing for both\n  // `.update(key, value, [returning])` and `.update(obj, [returning])` syntaxes.\n  update: function update(values, returning) {\n    var ret;\n    var obj = this._single.update || {};\n    this._method = 'update';\n\n    if ((0, _lodash.isString)(values)) {\n      obj[values] = returning;\n\n      if (arguments.length > 2) {\n        ret = arguments[2];\n      }\n    } else {\n      var keys = Object.keys(values);\n\n      if (this._single.update) {\n        this.client.logger.warn('Update called multiple times with objects.');\n      }\n\n      var i = -1;\n\n      while (++i < keys.length) {\n        obj[keys[i]] = values[keys[i]];\n      }\n\n      ret = arguments[1];\n    }\n\n    if (!(0, _lodash.isEmpty)(ret)) this.returning(ret);\n    this._single.update = obj;\n    return this;\n  },\n  // Sets the returning value for the query.\n  returning: function returning(_returning) {\n    this._single.returning = _returning;\n    return this;\n  },\n  // Delete\n  // ------\n  // Executes a delete statement on the query;\n  delete: function _delete(ret) {\n    this._method = 'del';\n    if (!(0, _lodash.isEmpty)(ret)) this.returning(ret);\n    return this;\n  },\n  // Truncates a table, ends the query chain.\n  truncate: function truncate(tableName) {\n    this._method = 'truncate';\n\n    if (tableName) {\n      this._single.table = tableName;\n    }\n\n    return this;\n  },\n  // Retrieves columns for the table specified by `knex(tableName)`\n  columnInfo: function columnInfo(column) {\n    this._method = 'columnInfo';\n    this._single.columnInfo = column;\n    return this;\n  },\n  // Set a lock for update constraint.\n  forUpdate: function forUpdate() {\n    this._single.lock = 'forUpdate';\n    this._single.lockTables = helpers.normalizeArr.apply(null, arguments);\n    return this;\n  },\n  // Set a lock for share constraint.\n  forShare: function forShare() {\n    this._single.lock = 'forShare';\n    this._single.lockTables = helpers.normalizeArr.apply(null, arguments);\n    return this;\n  },\n  // Takes a JS object of methods to call and calls them\n  fromJS: function fromJS(obj) {\n    var _this = this;\n\n    (0, _lodash.each)(obj, function (val, key) {\n      if (typeof _this[key] !== 'function') {\n        _this.client.logger.warn(\"Knex Error: unknown key \".concat(key));\n      }\n\n      if (Array.isArray(val)) {\n        _this[key].apply(_this, val);\n      } else {\n        _this[key](val);\n      }\n    });\n    return this;\n  },\n  // Passes query to provided callback function, useful for e.g. composing\n  // domain-specific helpers\n  modify: function modify(callback) {\n    callback.apply(this, [this].concat((0, _lodash.tail)(arguments)));\n    return this;\n  },\n  // ----------------------------------------------------------------------\n  // Helper for the incrementing/decrementing queries.\n  _counter: function _counter(column, amount) {\n    amount = parseFloat(amount);\n    this._method = 'update';\n    this._single.counter = this._single.counter || {};\n    this._single.counter[column] = amount;\n    return this;\n  },\n  // Helper to get or set the \"boolFlag\" value.\n  _bool: function _bool(val) {\n    if (arguments.length === 1) {\n      this._boolFlag = val;\n      return this;\n    }\n\n    var ret = this._boolFlag;\n    this._boolFlag = 'and';\n    return ret;\n  },\n  // Helper to get or set the \"notFlag\" value.\n  _not: function _not(val) {\n    if (arguments.length === 1) {\n      this._notFlag = val;\n      return this;\n    }\n\n    var ret = this._notFlag;\n    this._notFlag = false;\n    return ret;\n  },\n  // Helper to get or set the \"joinFlag\" value.\n  _joinType: function _joinType(val) {\n    if (arguments.length === 1) {\n      this._joinFlag = val;\n      return this;\n    }\n\n    var ret = this._joinFlag || 'inner';\n    this._joinFlag = 'inner';\n    return ret;\n  },\n  // Helper for compiling any aggregate queries.\n  _aggregate: function _aggregate(method, column, aggregateDistinct) {\n    this._statements.push({\n      grouping: 'columns',\n      type: column instanceof _raw.default ? 'aggregateRaw' : 'aggregate',\n      method: method,\n      value: column,\n      aggregateDistinct: aggregateDistinct || false\n    });\n\n    return this;\n  },\n  // Helper function for clearing or reseting a grouping type from the builder\n  _clearGrouping: function _clearGrouping(grouping) {\n    this._statements = (0, _lodash.reject)(this._statements, {\n      grouping: grouping\n    });\n  }\n});\nObject.defineProperty(Builder.prototype, 'or', {\n  get: function get() {\n    return this._bool('or');\n  }\n});\nObject.defineProperty(Builder.prototype, 'not', {\n  get: function get() {\n    return this._not(true);\n  }\n});\nBuilder.prototype.select = Builder.prototype.columns;\nBuilder.prototype.column = Builder.prototype.columns;\nBuilder.prototype.andWhereNot = Builder.prototype.whereNot;\nBuilder.prototype.andWhereNotColumn = Builder.prototype.whereNotColumn;\nBuilder.prototype.andWhere = Builder.prototype.where;\nBuilder.prototype.andWhereColumn = Builder.prototype.whereColumn;\nBuilder.prototype.andWhereRaw = Builder.prototype.whereRaw;\nBuilder.prototype.andWhereBetween = Builder.prototype.whereBetween;\nBuilder.prototype.andWhereNotBetween = Builder.prototype.whereNotBetween;\nBuilder.prototype.andHaving = Builder.prototype.having;\nBuilder.prototype.andHavingIn = Builder.prototype.havingIn;\nBuilder.prototype.andHavingNotIn = Builder.prototype.havingNotIn;\nBuilder.prototype.andHavingNull = Builder.prototype.havingNull;\nBuilder.prototype.andHavingNotNull = Builder.prototype.havingNotNull;\nBuilder.prototype.andHavingExists = Builder.prototype.havingExists;\nBuilder.prototype.andHavingNotExists = Builder.prototype.havingNotExists;\nBuilder.prototype.andHavingBetween = Builder.prototype.havingBetween;\nBuilder.prototype.andHavingNotBetween = Builder.prototype.havingNotBetween;\nBuilder.prototype.from = Builder.prototype.table;\nBuilder.prototype.into = Builder.prototype.table;\nBuilder.prototype.del = Builder.prototype.delete; // Attach all of the top level promise methods that should be chainable.\n\nrequire('../interface')(Builder);\n\nhelpers.addQueryContext(Builder);\nvar _default = Builder;\nexports.default = _default;\nmodule.exports = exports.default;","map":null,"metadata":{},"sourceType":"script"}