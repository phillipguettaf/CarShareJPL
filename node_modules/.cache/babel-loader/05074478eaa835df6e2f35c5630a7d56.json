{"ast":null,"code":"\"use strict\";\n\nvar _construct = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/construct\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Client_Oracle;\n\nvar _lodash = require(\"lodash\");\n\nvar _inherits = _interopRequireDefault(require(\"inherits\"));\n\nvar _client = _interopRequireDefault(require(\"../../client\"));\n\nvar _bluebird = _interopRequireDefault(require(\"bluebird\"));\n\nvar _string = require(\"../../query/string\");\n\nvar _formatter = _interopRequireDefault(require(\"./formatter\"));\n\nvar _transaction = _interopRequireDefault(require(\"./transaction\"));\n\nvar _compiler = _interopRequireDefault(require(\"./query/compiler\"));\n\nvar _compiler2 = _interopRequireDefault(require(\"./schema/compiler\"));\n\nvar _columnbuilder = _interopRequireDefault(require(\"./schema/columnbuilder\"));\n\nvar _columncompiler = _interopRequireDefault(require(\"./schema/columncompiler\"));\n\nvar _tablecompiler = _interopRequireDefault(require(\"./schema/tablecompiler\"));\n\nvar _utils = require(\"./utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // Oracle Client\n// -------\n// Always initialize with the \"QueryBuilder\" and \"QueryCompiler\"\n// objects, which extend the base 'lib/query/builder' and\n// 'lib/query/compiler', respectively.\n\n\nfunction Client_Oracle(config) {\n  _client.default.call(this, config);\n}\n\n(0, _inherits.default)(Client_Oracle, _client.default);\n(0, _lodash.assign)(Client_Oracle.prototype, {\n  dialect: 'oracle',\n  driverName: 'oracle',\n  _driver: function _driver() {\n    return require('oracle');\n  },\n  transaction: function transaction() {\n    return _construct(_transaction.default, [this].concat(Array.prototype.slice.call(arguments)));\n  },\n  formatter: function formatter() {\n    return _construct(_formatter.default, [this].concat(Array.prototype.slice.call(arguments)));\n  },\n  queryCompiler: function queryCompiler() {\n    return _construct(_compiler.default, [this].concat(Array.prototype.slice.call(arguments)));\n  },\n  schemaCompiler: function schemaCompiler() {\n    return _construct(_compiler2.default, [this].concat(Array.prototype.slice.call(arguments)));\n  },\n  columnBuilder: function columnBuilder() {\n    return _construct(_columnbuilder.default, [this].concat(Array.prototype.slice.call(arguments)));\n  },\n  columnCompiler: function columnCompiler() {\n    return _construct(_columncompiler.default, [this].concat(Array.prototype.slice.call(arguments)));\n  },\n  tableCompiler: function tableCompiler() {\n    return _construct(_tablecompiler.default, [this].concat(Array.prototype.slice.call(arguments)));\n  },\n  prepBindings: function prepBindings(bindings) {\n    var _this = this;\n\n    return (0, _lodash.map)(bindings, function (value) {\n      // returning helper uses always ROWID as string\n      if (value instanceof _utils.ReturningHelper && _this.driver) {\n        return new _this.driver.OutParam(_this.driver.OCCISTRING);\n      } else if (typeof value === 'boolean') {\n        return value ? 1 : 0;\n      } else if (Buffer.isBuffer(value)) {\n        return (0, _string.bufferToString)(value);\n      }\n\n      return value;\n    });\n  },\n  // Get a raw connection, called by the `pool` whenever a new\n  // connection needs to be added to the pool.\n  acquireRawConnection: function acquireRawConnection() {\n    var _this2 = this;\n\n    return new _bluebird.default(function (resolver, rejecter) {\n      _this2.driver.connect(_this2.connectionSettings, function (err, connection) {\n        if (err) return rejecter(err);\n\n        _bluebird.default.promisifyAll(connection);\n\n        if (_this2.connectionSettings.prefetchRowCount) {\n          connection.setPrefetchRowCount(_this2.connectionSettings.prefetchRowCount);\n        }\n\n        resolver(connection);\n      });\n    });\n  },\n  // Used to explicitly close a connection, called internally by the pool\n  // when a connection times out or the pool is shutdown.\n  destroyRawConnection: function destroyRawConnection(connection) {\n    return _bluebird.default.fromCallback(connection.close.bind(connection));\n  },\n  // Return the database for the Oracle client.\n  database: function database() {\n    return this.connectionSettings.database;\n  },\n  // Position the bindings for the query.\n  positionBindings: function positionBindings(sql) {\n    var questionCount = 0;\n    return sql.replace(/\\?/g, function () {\n      questionCount += 1;\n      return \":\".concat(questionCount);\n    });\n  },\n  _stream: function _stream(connection, obj, stream, options) {\n    return new _bluebird.default(function (resolver, rejecter) {\n      stream.on('error', function (err) {\n        if (isConnectionError(err)) {\n          connection.__knex__disposed = err;\n        }\n\n        rejecter(err);\n      });\n      stream.on('end', resolver);\n      var queryStream = connection.queryStream(obj.sql, obj.bindings, options);\n      queryStream.pipe(stream);\n      queryStream.on('error', function (error) {\n        rejecter(error);\n        stream.emit('error', error);\n      });\n    });\n  },\n  // Runs the query on the specified connection, providing the bindings\n  // and any other necessary prep work.\n  _query: function _query(connection, obj) {\n    if (!obj.sql) throw new Error('The query is empty');\n    return connection.executeAsync(obj.sql, obj.bindings).then(function (response) {\n      if (!obj.returning) return response;\n      var rowIds = obj.outParams.map(function (v, i) {\n        return response[\"returnParam\".concat(i ? i : '')];\n      });\n      return connection.executeAsync(obj.returningSql, rowIds);\n    }).then(function (response) {\n      obj.response = response;\n      obj.rowsAffected = response.updateCount;\n      return obj;\n    }).catch(function (err) {\n      if (isConnectionError(err)) {\n        connection.__knex__disposed = err;\n      }\n\n      throw err;\n    });\n  },\n  // Process the response as returned from the query.\n  processResponse: function processResponse(obj, runner) {\n    var response = obj.response;\n    var method = obj.method;\n    if (obj.output) return obj.output.call(runner, response);\n\n    switch (method) {\n      case 'select':\n      case 'pluck':\n      case 'first':\n        if (obj.method === 'pluck') response = (0, _lodash.map)(response, obj.pluck);\n        return obj.method === 'first' ? response[0] : response;\n\n      case 'insert':\n      case 'del':\n      case 'update':\n      case 'counter':\n        if (obj.returning) {\n          if (obj.returning.length > 1 || obj.returning[0] === '*') {\n            return response;\n          } // return an array with values if only one returning value was specified\n\n\n          return (0, _lodash.flatten)((0, _lodash.map)(response, _lodash.values));\n        }\n\n        return obj.rowsAffected;\n\n      default:\n        return response;\n    }\n  }\n}); // If the error is any of these, we'll assume we need to\n// mark the connection as failed\n\nvar connectionErrors = ['ORA-12514', 'NJS-040', 'NJS-024', 'NJS-003', 'NJS-024'];\n\nfunction isConnectionError(err) {\n  return connectionErrors.some(function (prefix) {\n    return err.message.indexOf(prefix) === 0;\n  });\n}\n\nmodule.exports = exports.default;","map":null,"metadata":{},"sourceType":"script"}