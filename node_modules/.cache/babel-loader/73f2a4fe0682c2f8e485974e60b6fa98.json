{"ast":null,"code":"\"use strict\";\n\nvar _construct = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/construct\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _inherits = _interopRequireDefault(require(\"inherits\"));\n\nvar _client = _interopRequireDefault(require(\"../../client\"));\n\nvar _bluebird = _interopRequireDefault(require(\"bluebird\"));\n\nvar _transaction = _interopRequireDefault(require(\"./transaction\"));\n\nvar _compiler = _interopRequireDefault(require(\"./query/compiler\"));\n\nvar _compiler2 = _interopRequireDefault(require(\"./schema/compiler\"));\n\nvar _tablecompiler = _interopRequireDefault(require(\"./schema/tablecompiler\"));\n\nvar _columncompiler = _interopRequireDefault(require(\"./schema/columncompiler\"));\n\nvar _lodash = require(\"lodash\");\n\nvar _string = require(\"../../query/string\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // MySQL Client\n// -------\n// Always initialize with the \"QueryBuilder\" and \"QueryCompiler\"\n// objects, which extend the base 'lib/query/builder' and\n// 'lib/query/compiler', respectively.\n\n\nfunction Client_MySQL(config) {\n  _client.default.call(this, config);\n}\n\n(0, _inherits.default)(Client_MySQL, _client.default);\n(0, _lodash.assign)(Client_MySQL.prototype, {\n  dialect: 'mysql',\n  driverName: 'mysql',\n  _driver: function _driver() {\n    return require('mysql');\n  },\n  queryCompiler: function queryCompiler() {\n    return _construct(_compiler.default, [this].concat(Array.prototype.slice.call(arguments)));\n  },\n  schemaCompiler: function schemaCompiler() {\n    return _construct(_compiler2.default, [this].concat(Array.prototype.slice.call(arguments)));\n  },\n  tableCompiler: function tableCompiler() {\n    return _construct(_tablecompiler.default, [this].concat(Array.prototype.slice.call(arguments)));\n  },\n  columnCompiler: function columnCompiler() {\n    return _construct(_columncompiler.default, [this].concat(Array.prototype.slice.call(arguments)));\n  },\n  transaction: function transaction() {\n    return _construct(_transaction.default, [this].concat(Array.prototype.slice.call(arguments)));\n  },\n  _escapeBinding: (0, _string.makeEscape)(),\n  wrapIdentifierImpl: function wrapIdentifierImpl(value) {\n    return value !== '*' ? \"`\".concat(value.replace(/`/g, '``'), \"`\") : '*';\n  },\n  // Get a raw connection, called by the `pool` whenever a new\n  // connection needs to be added to the pool.\n  acquireRawConnection: function acquireRawConnection() {\n    var _this = this;\n\n    return new _bluebird.default(function (resolver, rejecter) {\n      var connection = _this.driver.createConnection(_this.connectionSettings);\n\n      connection.on('error', function (err) {\n        connection.__knex__disposed = err;\n      });\n      connection.connect(function (err) {\n        if (err) {\n          // if connection is rejected, remove listener that was registered above...\n          connection.removeAllListeners();\n          return rejecter(err);\n        }\n\n        resolver(connection);\n      });\n    });\n  },\n  // Used to explicitly close a connection, called internally by the pool\n  // when a connection times out or the pool is shutdown.\n  destroyRawConnection: function destroyRawConnection(connection) {\n    return _bluebird.default.fromCallback(connection.end.bind(connection)).catch(function (err) {\n      connection.__knex__disposed = err;\n    }).finally(function () {\n      return connection.removeAllListeners();\n    });\n  },\n  validateConnection: function validateConnection(connection) {\n    if (connection.state === 'connected' || connection.state === 'authenticated') {\n      return true;\n    }\n\n    return false;\n  },\n  // Grab a connection, run the query via the MySQL streaming interface,\n  // and pass that through to the stream we've sent back to the client.\n  _stream: function _stream(connection, obj, stream, options) {\n    options = options || {};\n    var queryOptions = (0, _lodash.assign)({\n      sql: obj.sql\n    }, obj.options);\n    return new _bluebird.default(function (resolver, rejecter) {\n      stream.on('error', rejecter);\n      stream.on('end', resolver);\n      var queryStream = connection.query(queryOptions, obj.bindings).stream(options);\n      queryStream.on('error', function (err) {\n        rejecter(err);\n        stream.emit('error', err);\n      });\n      queryStream.pipe(stream);\n    });\n  },\n  // Runs the query on the specified connection, providing the bindings\n  // and any other necessary prep work.\n  _query: function _query(connection, obj) {\n    if (!obj || typeof obj === 'string') obj = {\n      sql: obj\n    };\n    return new _bluebird.default(function (resolver, rejecter) {\n      if (!obj.sql) {\n        resolver();\n        return;\n      }\n\n      var queryOptions = (0, _lodash.assign)({\n        sql: obj.sql\n      }, obj.options);\n      connection.query(queryOptions, obj.bindings, function (err, rows, fields) {\n        if (err) return rejecter(err);\n        obj.response = [rows, fields];\n        resolver(obj);\n      });\n    });\n  },\n  // Process the response as returned from the query.\n  processResponse: function processResponse(obj, runner) {\n    if (obj == null) return;\n    var response = obj.response;\n    var method = obj.method;\n    var rows = response[0];\n    var fields = response[1];\n    if (obj.output) return obj.output.call(runner, rows, fields);\n\n    switch (method) {\n      case 'select':\n      case 'pluck':\n      case 'first':\n        {\n          if (method === 'pluck') return (0, _lodash.map)(rows, obj.pluck);\n          return method === 'first' ? rows[0] : rows;\n        }\n\n      case 'insert':\n        return [rows.insertId];\n\n      case 'del':\n      case 'update':\n      case 'counter':\n        return rows.affectedRows;\n\n      default:\n        return response;\n    }\n  },\n  canCancelQuery: true,\n  cancelQuery: function cancelQuery(connectionToKill) {\n    var _this2 = this;\n\n    var acquiringConn = this.acquireConnection(); // Error out if we can't acquire connection in time.\n    // Purposely not putting timeout on `KILL QUERY` execution because erroring\n    // early there would release the `connectionToKill` back to the pool with\n    // a `KILL QUERY` command yet to finish.\n\n    return acquiringConn.timeout(100).then(function (conn) {\n      return _this2.query(conn, {\n        method: 'raw',\n        sql: 'KILL QUERY ?',\n        bindings: [connectionToKill.threadId],\n        options: {}\n      });\n    }).finally(function () {\n      // NOT returning this promise because we want to release the connection\n      // in a non-blocking fashion\n      acquiringConn.then(function (conn) {\n        return _this2.releaseConnection(conn);\n      });\n    });\n  }\n});\nvar _default = Client_MySQL;\nexports.default = _default;\nmodule.exports = exports.default;","map":null,"metadata":{},"sourceType":"script"}