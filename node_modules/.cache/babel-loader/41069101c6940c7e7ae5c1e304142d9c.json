{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _bluebird = _interopRequireDefault(require(\"bluebird\"));\n\nvar _events = require(\"events\");\n\nvar _debug = _interopRequireDefault(require(\"debug\"));\n\nvar _makeKnex = _interopRequireDefault(require(\"./util/make-knex\"));\n\nvar _lodash = require(\"lodash\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // Transaction\n// -------\n\n\nvar debug = (0, _debug.default)('knex:tx'); // Acts as a facade for a Promise, keeping the internal state\n// and managing any child transactions.\n\nvar Transaction =\n/*#__PURE__*/\nfunction (_events$EventEmitter) {\n  _inherits(Transaction, _events$EventEmitter);\n\n  function Transaction(client, container, config, outerTx) {\n    var _this;\n\n    _classCallCheck(this, Transaction);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Transaction).call(this));\n    var txid = _this.txid = (0, _lodash.uniqueId)('trx');\n    _this.client = client;\n    _this.logger = client.logger;\n    _this.outerTx = outerTx;\n    _this.trxClient = undefined;\n    _this._debug = client.config && client.config.debug;\n    debug('%s: Starting %s transaction', txid, outerTx ? 'nested' : 'top level');\n    _this._promise = _bluebird.default.using(_this.acquireConnection(client, config, txid), function (connection) {\n      var trxClient = _this.trxClient = makeTxClient(_assertThisInitialized(_assertThisInitialized(_this)), client, connection);\n      var init = client.transacting ? _this.savepoint(connection) : _this.begin(connection);\n      init.then(function () {\n        return makeTransactor(_assertThisInitialized(_assertThisInitialized(_this)), connection, trxClient);\n      }).then(function (transactor) {\n        // If we've returned a \"thenable\" from the transaction container, assume\n        // the rollback and commit are chained to this object's success / failure.\n        // Directly thrown errors are treated as automatic rollbacks.\n        var result;\n\n        try {\n          result = container(transactor);\n        } catch (err) {\n          result = _bluebird.default.reject(err);\n        }\n\n        if (result && result.then && typeof result.then === 'function') {\n          result.then(function (val) {\n            return transactor.commit(val);\n          }).catch(function (err) {\n            return transactor.rollback(err);\n          });\n        }\n\n        return null;\n      }).catch(function (e) {\n        return _this._rejecter(e);\n      });\n      return new _bluebird.default(function (resolver, rejecter) {\n        _this._resolver = resolver;\n        _this._rejecter = rejecter;\n      });\n    });\n    _this._completed = false; // If there's a wrapping transaction, we need to wait for any older sibling\n    // transactions to settle (commit or rollback) before we can start, and we\n    // need to register ourselves with the parent transaction so any younger\n    // siblings can wait for us to complete before they can start.\n\n    _this._previousSibling = _bluebird.default.resolve(true);\n\n    if (outerTx) {\n      if (outerTx._lastChild) _this._previousSibling = outerTx._lastChild;\n      outerTx._lastChild = _this._promise;\n    }\n\n    return _this;\n  }\n\n  _createClass(Transaction, [{\n    key: \"isCompleted\",\n    value: function isCompleted() {\n      return this._completed || this.outerTx && this.outerTx.isCompleted() || false;\n    }\n  }, {\n    key: \"begin\",\n    value: function begin(conn) {\n      return this.query(conn, 'BEGIN;');\n    }\n  }, {\n    key: \"savepoint\",\n    value: function savepoint(conn) {\n      return this.query(conn, \"SAVEPOINT \".concat(this.txid, \";\"));\n    }\n  }, {\n    key: \"commit\",\n    value: function commit(conn, value) {\n      return this.query(conn, 'COMMIT;', 1, value);\n    }\n  }, {\n    key: \"release\",\n    value: function release(conn, value) {\n      return this.query(conn, \"RELEASE SAVEPOINT \".concat(this.txid, \";\"), 1, value);\n    }\n  }, {\n    key: \"rollback\",\n    value: function rollback(conn, error) {\n      var _this2 = this;\n\n      return this.query(conn, 'ROLLBACK', 2, error).timeout(5000).catch(_bluebird.default.TimeoutError, function () {\n        _this2._rejecter(error);\n      });\n    }\n  }, {\n    key: \"rollbackTo\",\n    value: function rollbackTo(conn, error) {\n      var _this3 = this;\n\n      return this.query(conn, \"ROLLBACK TO SAVEPOINT \".concat(this.txid), 2, error).timeout(5000).catch(_bluebird.default.TimeoutError, function () {\n        _this3._rejecter(error);\n      });\n    }\n  }, {\n    key: \"query\",\n    value: function query(conn, sql, status, value) {\n      var _this4 = this;\n\n      var q = this.trxClient.query(conn, sql).catch(function (err) {\n        status = 2;\n        value = err;\n        _this4._completed = true;\n        debug('%s error running transaction query', _this4.txid);\n      }).tap(function () {\n        if (status === 1) {\n          _this4._resolver(value);\n        }\n\n        if (status === 2) {\n          if ((0, _lodash.isUndefined)(value)) {\n            value = new Error(\"Transaction rejected with non-error: \".concat(value));\n          }\n\n          _this4._rejecter(value);\n        }\n      });\n\n      if (status === 1 || status === 2) {\n        this._completed = true;\n      }\n\n      return q;\n    }\n  }, {\n    key: \"debug\",\n    value: function debug(enabled) {\n      this._debug = arguments.length ? enabled : true;\n      return this;\n    } // Acquire a connection and create a disposer - either using the one passed\n    // via config or getting one off the client. The disposer will be called once\n    // the original promise is marked completed.\n\n  }, {\n    key: \"acquireConnection\",\n    value: function acquireConnection(client, config, txid) {\n      var configConnection = config && config.connection;\n      return _bluebird.default.try(function () {\n        return configConnection || client.acquireConnection();\n      }).then(function (connection) {\n        connection.__knexTxId = txid;\n        return connection;\n      }).disposer(function (connection) {\n        if (!configConnection) {\n          debug('%s: releasing connection', txid);\n          client.releaseConnection(connection);\n        } else {\n          debug('%s: not releasing external connection', txid);\n        }\n      });\n    }\n  }]);\n\n  return Transaction;\n}(_events.EventEmitter); // The transactor is a full featured knex object, with a \"commit\", a \"rollback\"\n// and a \"savepoint\" function. The \"savepoint\" is just sugar for creating a new\n// transaction. If the rollback is run inside a savepoint, it rolls back to the\n// last savepoint - otherwise it rolls back the transaction.\n\n\nexports.default = Transaction;\n\nfunction makeTransactor(trx, connection, trxClient) {\n  var transactor = (0, _makeKnex.default)(trxClient);\n\n  transactor.withUserParams = function () {\n    throw new Error('Cannot set user params on a transaction - it can only inherit params from main knex instance');\n  };\n\n  transactor.userParams = trx.userParams;\n\n  transactor.transaction = function (container, options) {\n    return trxClient.transaction(container, options, trx);\n  };\n\n  transactor.savepoint = function (container, options) {\n    return transactor.transaction(container, options);\n  };\n\n  if (trx.client.transacting) {\n    transactor.commit = function (value) {\n      return trx.release(connection, value);\n    };\n\n    transactor.rollback = function (error) {\n      return trx.rollbackTo(connection, error);\n    };\n  } else {\n    transactor.commit = function (value) {\n      return trx.commit(connection, value);\n    };\n\n    transactor.rollback = function (error) {\n      return trx.rollback(connection, error);\n    };\n  }\n\n  return transactor;\n} // We need to make a client object which always acquires the same\n// connection and does not release back into the pool.\n\n\nfunction makeTxClient(trx, client, connection) {\n  var trxClient = Object.create(client.constructor.prototype);\n  trxClient.version = client.version;\n  trxClient.config = client.config;\n  trxClient.driver = client.driver;\n  trxClient.connectionSettings = client.connectionSettings;\n  trxClient.transacting = true;\n  trxClient.valueForUndefined = client.valueForUndefined;\n  trxClient.logger = client.logger;\n  trxClient.on('query', function (arg) {\n    trx.emit('query', arg);\n    client.emit('query', arg);\n  });\n  trxClient.on('query-error', function (err, obj) {\n    trx.emit('query-error', err, obj);\n    client.emit('query-error', err, obj);\n  });\n  trxClient.on('query-response', function (response, obj, builder) {\n    trx.emit('query-response', response, obj, builder);\n    client.emit('query-response', response, obj, builder);\n  });\n  var _query = trxClient.query;\n\n  trxClient.query = function (conn, obj) {\n    var completed = trx.isCompleted();\n    return _bluebird.default.try(function () {\n      if (conn !== connection) throw new Error('Invalid connection for transaction query.');\n      if (completed) completedError(trx, obj);\n      return _query.call(trxClient, conn, obj);\n    });\n  };\n\n  var _stream = trxClient.stream;\n\n  trxClient.stream = function (conn, obj, stream, options) {\n    var completed = trx.isCompleted();\n    return _bluebird.default.try(function () {\n      if (conn !== connection) throw new Error('Invalid connection for transaction query.');\n      if (completed) completedError(trx, obj);\n      return _stream.call(trxClient, conn, obj, stream, options);\n    });\n  };\n\n  trxClient.acquireConnection = function () {\n    return _bluebird.default.resolve(connection);\n  };\n\n  trxClient.releaseConnection = function () {\n    return _bluebird.default.resolve();\n  };\n\n  return trxClient;\n}\n\nfunction completedError(trx, obj) {\n  var sql = typeof obj === 'string' ? obj : obj && obj.sql;\n  debug('%s: Transaction completed: %s', trx.txid, sql);\n  throw new Error('Transaction query already complete, run with DEBUG=knex:tx for more info');\n}\n\nvar promiseInterface = ['then', 'bind', 'catch', 'finally', 'asCallback', 'spread', 'map', 'reduce', 'tap', 'thenReturn', 'return', 'yield', 'ensure', 'exec', 'reflect', 'get', 'mapSeries', 'delay']; // Creates methods which proxy promise interface methods to\n// internal transaction resolution promise\n\npromiseInterface.forEach(function (method) {\n  Transaction.prototype[method] = function () {\n    return this._promise[method].apply(this._promise, arguments);\n  };\n});\nmodule.exports = exports.default;","map":null,"metadata":{},"sourceType":"script"}