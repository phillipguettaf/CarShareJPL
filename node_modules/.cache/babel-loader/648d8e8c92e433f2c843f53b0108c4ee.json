{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = ColumnBuilder;\n\nvar _lodash = require(\"lodash\");\n\nvar _helpers = require(\"../helpers\"); // The chainable interface off the original \"column\" method.\n\n\nfunction ColumnBuilder(client, tableBuilder, type, args) {\n  this.client = client;\n  this._method = 'add';\n  this._single = {};\n  this._modifiers = {};\n  this._statements = [];\n  this._type = columnAlias[type] || type;\n  this._args = args;\n  this._tableBuilder = tableBuilder; // If we're altering the table, extend the object\n  // with the available \"alter\" methods.\n\n  if (tableBuilder._method === 'alter') {\n    (0, _lodash.extend)(this, AlterMethods);\n  }\n} // All of the modifier methods that can be used to modify the current query.\n\n\nvar modifiers = ['default', 'defaultsTo', 'defaultTo', 'unsigned', 'nullable', 'first', 'after', 'comment', 'collate']; // Aliases for convenience.\n\nvar aliasMethod = {\n  default: 'defaultTo',\n  defaultsTo: 'defaultTo'\n}; // If we call any of the modifiers (index or otherwise) on the chainable, we pretend\n// as though we're calling `table.method(column)` directly.\n\n(0, _lodash.each)(modifiers, function (method) {\n  var key = aliasMethod[method] || method;\n\n  ColumnBuilder.prototype[method] = function () {\n    this._modifiers[key] = (0, _lodash.toArray)(arguments);\n    return this;\n  };\n});\n(0, _helpers.addQueryContext)(ColumnBuilder);\n\nColumnBuilder.prototype.notNull = ColumnBuilder.prototype.notNullable = function notNullable() {\n  return this.nullable(false);\n};\n\n(0, _lodash.each)(['index', 'primary', 'unique'], function (method) {\n  ColumnBuilder.prototype[method] = function () {\n    if (this._type.toLowerCase().indexOf('increments') === -1) {\n      this._tableBuilder[method].apply(this._tableBuilder, [this._args[0]].concat((0, _lodash.toArray)(arguments)));\n    }\n\n    return this;\n  };\n}); // Specify that the current column \"references\" a column,\n// which may be tableName.column or just \"column\"\n\nColumnBuilder.prototype.references = function (value) {\n  return this._tableBuilder.foreign.call(this._tableBuilder, this._args[0], undefined, this)._columnBuilder(this).references(value);\n};\n\nvar AlterMethods = {}; // Specify that the column is to be dropped. This takes precedence\n// over all other rules for the column.\n\nAlterMethods.drop = function () {\n  this._single.drop = true;\n  return this;\n}; // Specify the \"type\" that we're looking to set the\n// Knex takes no responsibility for any data-loss that may\n// occur when changing data types.\n\n\nAlterMethods.alterType = function (type) {\n  this._statements.push({\n    grouping: 'alterType',\n    value: type\n  });\n\n  return this;\n}; // Set column method to alter (default is add).\n\n\nAlterMethods.alter = function () {\n  this._method = 'alter';\n  return this;\n}; // Alias a few methods for clarity when processing.\n\n\nvar columnAlias = {\n  float: 'floating',\n  enum: 'enu',\n  boolean: 'bool',\n  string: 'varchar',\n  bigint: 'bigInteger'\n};\nmodule.exports = exports.default;","map":null,"metadata":{},"sourceType":"script"}