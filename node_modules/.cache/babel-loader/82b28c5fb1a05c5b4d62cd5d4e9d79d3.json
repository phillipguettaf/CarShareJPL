{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _lodash = require(\"lodash\");\n\nvar _inherits = _interopRequireDefault(require(\"inherits\"));\n\nvar _compiler = _interopRequireDefault(require(\"../../../query/compiler\"));\n\nvar _utils = require(\"../utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/* eslint max-len:0 */\n// Oracle Query Builder & Compiler\n// ------\n\n\nvar components = ['columns', 'join', 'where', 'union', 'group', 'having', 'order', 'lock']; // Query Compiler\n// -------\n// Set the \"Formatter\" to use for the queries,\n// ensuring that all parameterized values (even across sub-queries)\n// are properly built into the same query.\n\nfunction QueryCompiler_Oracle(client, builder) {\n  _compiler.default.call(this, client, builder);\n}\n\n(0, _inherits.default)(QueryCompiler_Oracle, _compiler.default);\n(0, _lodash.assign)(QueryCompiler_Oracle.prototype, {\n  // Compiles an \"insert\" query, allowing for multiple\n  // inserts using a single query statement.\n  insert: function insert() {\n    var _this = this;\n\n    var insertValues = this.single.insert || [];\n    var returning = this.single.returning;\n\n    if (!Array.isArray(insertValues) && (0, _lodash.isPlainObject)(this.single.insert)) {\n      insertValues = [this.single.insert];\n    } // always wrap returning argument in array\n\n\n    if (returning && !Array.isArray(returning)) {\n      returning = [returning];\n    }\n\n    if (Array.isArray(insertValues) && insertValues.length === 1 && (0, _lodash.isEmpty)(insertValues[0])) {\n      return this._addReturningToSqlAndConvert(\"insert into \".concat(this.tableName, \" (\").concat(this.formatter.wrap(this.single.returning), \") values (default)\"), returning, this.tableName);\n    }\n\n    if ((0, _lodash.isEmpty)(this.single.insert) && typeof this.single.insert !== 'function') {\n      return '';\n    }\n\n    var insertData = this._prepInsert(insertValues);\n\n    var sql = {};\n\n    if ((0, _lodash.isString)(insertData)) {\n      return this._addReturningToSqlAndConvert(\"insert into \".concat(this.tableName, \" \").concat(insertData), returning);\n    }\n\n    if (insertData.values.length === 1) {\n      return this._addReturningToSqlAndConvert(\"insert into \".concat(this.tableName, \" (\").concat(this.formatter.columnize(insertData.columns), \") values (\").concat(this.formatter.parameterize(insertData.values[0]), \")\"), returning, this.tableName);\n    }\n\n    var insertDefaultsOnly = insertData.columns.length === 0;\n    sql.sql = 'begin ' + (0, _lodash.map)(insertData.values, function (value) {\n      var returningHelper;\n      var parameterizedValues = !insertDefaultsOnly ? _this.formatter.parameterize(value, _this.client.valueForUndefined) : '';\n      var returningValues = Array.isArray(returning) ? returning : [returning];\n      var subSql = \"insert into \".concat(_this.tableName, \" \");\n\n      if (returning) {\n        returningHelper = new _utils.ReturningHelper(returningValues.join(':'));\n        sql.outParams = (sql.outParams || []).concat(returningHelper);\n      }\n\n      if (insertDefaultsOnly) {\n        // no columns given so only the default value\n        subSql += \"(\".concat(_this.formatter.wrap(_this.single.returning), \") values (default)\");\n      } else {\n        subSql += \"(\".concat(_this.formatter.columnize(insertData.columns), \") values (\").concat(parameterizedValues, \")\");\n      }\n\n      subSql += returning ? \" returning ROWID into \".concat(_this.formatter.parameter(returningHelper)) : ''; // pre bind position because subSql is an execute immediate parameter\n      // later position binding will only convert the ? params\n\n      subSql = _this.formatter.client.positionBindings(subSql);\n      var parameterizedValuesWithoutDefault = parameterizedValues.replace('DEFAULT, ', '').replace(', DEFAULT', '');\n      return \"execute immediate '\".concat(subSql.replace(/'/g, \"''\")) + (parameterizedValuesWithoutDefault || returning ? \"' using \" : '') + parameterizedValuesWithoutDefault + (parameterizedValuesWithoutDefault && returning ? ', ' : '') + (returning ? 'out ?' : '') + ';';\n    }).join(' ') + 'end;';\n\n    if (returning) {\n      sql.returning = returning; // generate select statement with special order by to keep the order because 'in (..)' may change the order\n\n      sql.returningSql = \"select \".concat(this.formatter.columnize(returning)) + ' from ' + this.tableName + ' where ROWID in (' + sql.outParams.map(function (v, i) {\n        return \":\".concat(i + 1);\n      }).join(', ') + ')' + ' order by case ROWID ' + sql.outParams.map(function (v, i) {\n        return \"when CHARTOROWID(:\".concat(i + 1, \") then \").concat(i);\n      }).join(' ') + ' end';\n    }\n\n    return sql;\n  },\n  // Update method, including joins, wheres, order & limits.\n  update: function update() {\n    var updates = this._prepUpdate(this.single.update);\n\n    var where = this.where();\n    var returning = this.single.returning;\n    var sql = \"update \".concat(this.tableName) + ' set ' + updates.join(', ') + (where ? \" \".concat(where) : '');\n\n    if (!returning) {\n      return sql;\n    } // always wrap returning argument in array\n\n\n    if (!Array.isArray(returning)) {\n      returning = [returning];\n    }\n\n    return this._addReturningToSqlAndConvert(sql, returning, this.tableName);\n  },\n  // Compiles a `truncate` query.\n  truncate: function truncate() {\n    return \"truncate table \".concat(this.tableName);\n  },\n  forUpdate: function forUpdate() {\n    return 'for update';\n  },\n  forShare: function forShare() {\n    // lock for share is not directly supported by oracle\n    // use LOCK TABLE .. IN SHARE MODE; instead\n    this.client.logger.warn('lock for share is not supported by oracle dialect');\n    return '';\n  },\n  // Compiles a `columnInfo` query.\n  columnInfo: function columnInfo() {\n    var column = this.single.columnInfo; // The user may have specified a custom wrapIdentifier function in the config. We\n    // need to run the identifiers through that function, but not format them as\n    // identifiers otherwise.\n\n    var table = this.client.customWrapIdentifier(this.single.table, _lodash.identity); // Node oracle drivers doesn't support LONG type (which is data_default type)\n\n    var sql = \"select * from xmltable( '/ROWSET/ROW'\\n      passing dbms_xmlgen.getXMLType('\\n      select char_col_decl_length, column_name, data_type, data_default, nullable\\n      from user_tab_columns where table_name = ''\".concat(table, \"'' ')\\n      columns\\n      CHAR_COL_DECL_LENGTH number, COLUMN_NAME varchar2(200), DATA_TYPE varchar2(106),\\n      DATA_DEFAULT clob, NULLABLE varchar2(1))\");\n    return {\n      sql: sql,\n      output: function output(resp) {\n        var out = (0, _lodash.reduce)(resp, function (columns, val) {\n          columns[val.COLUMN_NAME] = {\n            type: val.DATA_TYPE,\n            defaultValue: val.DATA_DEFAULT,\n            maxLength: val.CHAR_COL_DECL_LENGTH,\n            nullable: val.NULLABLE === 'Y'\n          };\n          return columns;\n        }, {});\n        return column && out[column] || out;\n      }\n    };\n  },\n  select: function select() {\n    var _this2 = this;\n\n    var query = this.with();\n    var statements = (0, _lodash.map)(components, function (component) {\n      return _this2[component]();\n    });\n    query += (0, _lodash.compact)(statements).join(' ');\n    return this._surroundQueryWithLimitAndOffset(query);\n  },\n  aggregate: function aggregate(stmt) {\n    return this._aggregate(stmt, {\n      aliasSeparator: ' '\n    });\n  },\n  // for single commands only\n  _addReturningToSqlAndConvert: function _addReturningToSqlAndConvert(sql, returning, tableName) {\n    var res = {\n      sql: sql\n    };\n\n    if (!returning) {\n      return res;\n    }\n\n    var returningValues = Array.isArray(returning) ? returning : [returning];\n    var returningHelper = new _utils.ReturningHelper(returningValues.join(':'));\n    res.sql = sql + ' returning ROWID into ' + this.formatter.parameter(returningHelper);\n    res.returningSql = \"select \".concat(this.formatter.columnize(returning), \" from \").concat(tableName, \" where ROWID = :1\");\n    res.outParams = [returningHelper];\n    res.returning = returning;\n    return res;\n  },\n  _surroundQueryWithLimitAndOffset: function _surroundQueryWithLimitAndOffset(query) {\n    var limit = this.single.limit;\n    var offset = this.single.offset;\n    var hasLimit = limit || limit === 0 || limit === '0';\n    limit = +limit;\n    if (!hasLimit && !offset) return query;\n    query = query || '';\n\n    if (hasLimit && !offset) {\n      return \"select * from (\".concat(query, \") where rownum <= \").concat(this.formatter.parameter(limit));\n    }\n\n    var endRow = +offset + (hasLimit ? limit : 10000000000000);\n    return 'select * from ' + '(select row_.*, ROWNUM rownum_ from (' + query + ') row_ ' + 'where rownum <= ' + this.formatter.parameter(endRow) + ') ' + 'where rownum_ > ' + this.formatter.parameter(offset);\n  }\n}); // Compiles the `select` statement, or nested sub-selects\n// by calling each of the component compilers, trimming out\n// the empties, and returning a generated query string.\n\nQueryCompiler_Oracle.prototype.first = QueryCompiler_Oracle.prototype.select;\nvar _default = QueryCompiler_Oracle;\nexports.default = _default;\nmodule.exports = exports.default;","map":null,"metadata":{},"sourceType":"script"}