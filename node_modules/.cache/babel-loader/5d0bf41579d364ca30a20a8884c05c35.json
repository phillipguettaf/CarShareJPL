{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getMergedConfig = getMergedConfig;\nexports.default = void 0;\n\nvar _bluebird = _interopRequireDefault(require(\"bluebird\"));\n\nvar _lodash = require(\"lodash\");\n\nvar _inherits = _interopRequireDefault(require(\"inherits\"));\n\nvar _tableResolver = require(\"./table-resolver\");\n\nvar _tableCreator = require(\"./table-creator\");\n\nvar migrationListResolver = _interopRequireWildcard(require(\"./migration-list-resolver\"));\n\nvar _fsMigrations = _interopRequireWildcard(require(\"./sources/fs-migrations\"));\n\nvar _MigrationGenerator = _interopRequireDefault(require(\"./MigrationGenerator\"));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction LockError(msg) {\n  this.name = 'MigrationLocked';\n  this.message = msg;\n}\n\n(0, _inherits.default)(LockError, Error);\nvar CONFIG_DEFAULT = Object.freeze({\n  extension: 'js',\n  loadExtensions: _fsMigrations.DEFAULT_LOAD_EXTENSIONS,\n  tableName: 'knex_migrations',\n  schemaName: null,\n  directory: './migrations',\n  disableTransactions: false,\n  sortDirsSeparately: false\n}); // The new migration we're performing, typically called from the `knex.migrate`\n// interface on the main `knex` object. Passes the `knex` instance performing\n// the migration.\n\nvar Migrator =\n/*#__PURE__*/\nfunction () {\n  function Migrator(knex) {\n    _classCallCheck(this, Migrator);\n\n    // Clone knex instance and remove post-processing that is unnecessary for internal queries from a cloned config\n    if ((0, _lodash.isFunction)(knex)) {\n      this.knex = knex.withUserParams(_objectSpread({}, knex.userParams));\n      this.knex.disableProcessing();\n    } else {\n      this.knex = Object.assign({}, knex);\n    }\n\n    this.config = getMergedConfig(this.knex.client.config.migrations);\n    this.generator = new _MigrationGenerator.default(this.knex.client.config.migrations);\n    this._activeMigration = {\n      fileName: null\n    };\n  } // Migrators to the latest configuration.\n\n\n  _createClass(Migrator, [{\n    key: \"latest\",\n    value: function latest(config) {\n      var _this = this;\n\n      this.config = getMergedConfig(config, this.config);\n      return migrationListResolver.listAllAndCompleted(this.config, this.knex).tap(function (value) {\n        return validateMigrationList(_this.config.migrationSource, value);\n      }).spread(function (all, completed) {\n        var migrations = getNewMigrations(_this.config.migrationSource, all, completed);\n        var transactionForAll = !_this.config.disableTransactions && (0, _lodash.isEmpty)((0, _lodash.filter)(migrations, function (migration) {\n          var migrationContents = _this.config.migrationSource.getMigration(migration);\n\n          return !_this._useTransaction(migrationContents);\n        }));\n\n        if (transactionForAll) {\n          return _this.knex.transaction(function (trx) {\n            return _this._runBatch(migrations, 'up', trx);\n          });\n        } else {\n          return _this._runBatch(migrations, 'up');\n        }\n      });\n    } // Rollback the last \"batch\" of migrations that were run.\n\n  }, {\n    key: \"rollback\",\n    value: function rollback(config) {\n      var _this2 = this;\n\n      return _bluebird.default.try(function () {\n        _this2.config = getMergedConfig(config, _this2.config);\n        return migrationListResolver.listAllAndCompleted(_this2.config, _this2.knex).tap(function (value) {\n          return validateMigrationList(_this2.config.migrationSource, value);\n        }).then(function (val) {\n          return _this2._getLastBatch(val);\n        }).then(function (migrations) {\n          return _this2._runBatch(migrations, 'down');\n        });\n      });\n    }\n  }, {\n    key: \"status\",\n    value: function status(config) {\n      this.config = getMergedConfig(config, this.config);\n      return _bluebird.default.all([(0, _tableResolver.getTable)(this.knex, this.config.tableName, this.config.schemaName).select('*'), migrationListResolver.listAll(this.config.migrationSource)]).spread(function (db, code) {\n        return db.length - code.length;\n      });\n    } // Retrieves and returns the current migration version we're on, as a promise.\n    // If no migrations have been run yet, return \"none\".\n\n  }, {\n    key: \"currentVersion\",\n    value: function currentVersion(config) {\n      this.config = getMergedConfig(config, this.config);\n      return migrationListResolver.listCompleted(this.config.tableName, this.config.schemaName, this.knex).then(function (completed) {\n        var val = (0, _lodash.max)(completed.map(function (value) {\n          return value.split('_')[0];\n        }));\n        return (0, _lodash.isUndefined)(val) ? 'none' : val;\n      });\n    }\n  }, {\n    key: \"forceFreeMigrationsLock\",\n    value: function forceFreeMigrationsLock(config) {\n      var _this3 = this;\n\n      this.config = getMergedConfig(config, this.config);\n      var lockTable = (0, _tableResolver.getLockTableName)(this.config.tableName);\n      return (0, _tableCreator.getSchemaBuilder)(this.knex, this.config.schemaName).hasTable(lockTable).then(function (exist) {\n        return exist && _this3._freeLock();\n      });\n    } // Creates a new migration, with a given name.\n\n  }, {\n    key: \"make\",\n    value: function make(name, config) {\n      this.config = getMergedConfig(config, this.config);\n      return this.generator.make(name, this.config);\n    }\n  }, {\n    key: \"_isLocked\",\n    value: function _isLocked(trx) {\n      var tableName = (0, _tableResolver.getLockTableName)(this.config.tableName);\n      return (0, _tableResolver.getTable)(this.knex, tableName, this.config.schemaName).transacting(trx).forUpdate().select('*').then(function (data) {\n        return data[0].is_locked;\n      });\n    }\n  }, {\n    key: \"_lockMigrations\",\n    value: function _lockMigrations(trx) {\n      var tableName = (0, _tableResolver.getLockTableName)(this.config.tableName);\n      return (0, _tableResolver.getTable)(this.knex, tableName, this.config.schemaName).transacting(trx).update({\n        is_locked: 1\n      });\n    }\n  }, {\n    key: \"_getLock\",\n    value: function _getLock(trx) {\n      var _this4 = this;\n\n      var transact = trx ? function (fn) {\n        return fn(trx);\n      } : function (fn) {\n        return _this4.knex.transaction(fn);\n      };\n      return transact(function (trx) {\n        return _this4._isLocked(trx).then(function (isLocked) {\n          if (isLocked) {\n            throw new Error('Migration table is already locked');\n          }\n        }).then(function () {\n          return _this4._lockMigrations(trx);\n        });\n      }).catch(function (err) {\n        throw new LockError(err.message);\n      });\n    }\n  }, {\n    key: \"_freeLock\",\n    value: function _freeLock() {\n      var trx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.knex;\n      var tableName = (0, _tableResolver.getLockTableName)(this.config.tableName);\n      return (0, _tableResolver.getTable)(trx, tableName, this.config.schemaName).update({\n        is_locked: 0\n      });\n    } // Run a batch of current migrations, in sequence.\n\n  }, {\n    key: \"_runBatch\",\n    value: function _runBatch(migrations, direction, trx) {\n      var _this5 = this;\n\n      return this._getLock(trx) // When there is a wrapping transaction, some migrations\n      // could have been done while waiting for the lock:\n      .then(function () {\n        return trx ? migrationListResolver.listCompleted(_this5.config.tableName, _this5.config.schemaName, trx) : [];\n      }).then(function (completed) {\n        return migrations = getNewMigrations(_this5.config.migrationSource, migrations, completed);\n      }).then(function () {\n        return _bluebird.default.all(migrations.map(_this5._validateMigrationStructure.bind(_this5)));\n      }).then(function () {\n        return _this5._latestBatchNumber(trx);\n      }).then(function (batchNo) {\n        if (direction === 'up') batchNo++;\n        return batchNo;\n      }).then(function (batchNo) {\n        return _this5._waterfallBatch(batchNo, migrations, direction, trx);\n      }).tap(function () {\n        return _this5._freeLock(trx);\n      }).catch(function (error) {\n        var cleanupReady = _bluebird.default.resolve();\n\n        if (error instanceof LockError) {\n          // If locking error do not free the lock.\n          _this5.knex.client.logger.warn(\"Can't take lock to run migrations: \".concat(error.message));\n\n          _this5.knex.client.logger.warn('If you are sure migrations are not running you can release the ' + 'lock manually by deleting all the rows from migrations lock ' + 'table: ' + (0, _tableResolver.getLockTableNameWithSchema)(_this5.config.tableName, _this5.config.schemaName));\n        } else {\n          if (_this5._activeMigration.fileName) {\n            _this5.knex.client.logger.warn(\"migration file \\\"\".concat(_this5._activeMigration.fileName, \"\\\" failed\"));\n          }\n\n          _this5.knex.client.logger.warn(\"migration failed with error: \".concat(error.message)); // If the error was not due to a locking issue, then remove the lock.\n\n\n          cleanupReady = _this5._freeLock(trx);\n        }\n\n        return cleanupReady.finally(function () {\n          throw error;\n        });\n      });\n    } // Validates some migrations by requiring and checking for an `up` and `down`\n    // function.\n\n  }, {\n    key: \"_validateMigrationStructure\",\n    value: function _validateMigrationStructure(migration) {\n      var migrationName = this.config.migrationSource.getMigrationName(migration);\n      var migrationContent = this.config.migrationSource.getMigration(migration);\n\n      if (typeof migrationContent.up !== 'function' || typeof migrationContent.down !== 'function') {\n        throw new Error(\"Invalid migration: \".concat(migrationName, \" must have both an up and down function\"));\n      }\n\n      return migration;\n    } // Get the last batch of migrations, by name, ordered by insert id in reverse\n    // order.\n\n  }, {\n    key: \"_getLastBatch\",\n    value: function _getLastBatch(_ref) {\n      var _this6 = this;\n\n      var _ref2 = _slicedToArray(_ref, 1),\n          allMigrations = _ref2[0];\n\n      var _this$config = this.config,\n          tableName = _this$config.tableName,\n          schemaName = _this$config.schemaName;\n      return (0, _tableResolver.getTable)(this.knex, tableName, schemaName).where('batch', function (qb) {\n        qb.max('batch').from((0, _tableResolver.getTableName)(tableName, schemaName));\n      }).orderBy('id', 'desc').map(function (migration) {\n        return allMigrations.find(function (entry) {\n          return _this6.config.migrationSource.getMigrationName(entry) === migration.name;\n        });\n      });\n    } // Returns the latest batch number.\n\n  }, {\n    key: \"_latestBatchNumber\",\n    value: function _latestBatchNumber() {\n      var trx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.knex;\n      return trx.from((0, _tableResolver.getTableName)(this.config.tableName, this.config.schemaName)).max('batch as max_batch').then(function (obj) {\n        return obj[0].max_batch || 0;\n      });\n    } // If transaction config for a single migration is defined, use that.\n    // Otherwise, rely on the common config. This allows enabling/disabling\n    // transaction for a single migration at will, regardless of the common\n    // config.\n\n  }, {\n    key: \"_useTransaction\",\n    value: function _useTransaction(migrationContent, allTransactionsDisabled) {\n      var singleTransactionValue = (0, _lodash.get)(migrationContent, 'config.transaction');\n      return (0, _lodash.isBoolean)(singleTransactionValue) ? singleTransactionValue : !allTransactionsDisabled;\n    } // Runs a batch of `migrations` in a specified `direction`, saving the\n    // appropriate database information as the migrations are run.\n\n  }, {\n    key: \"_waterfallBatch\",\n    value: function _waterfallBatch(batchNo, migrations, direction, trx) {\n      var _this7 = this;\n\n      var trxOrKnex = trx || this.knex;\n      var _this$config2 = this.config,\n          tableName = _this$config2.tableName,\n          schemaName = _this$config2.schemaName,\n          disableTransactions = _this$config2.disableTransactions;\n\n      var current = _bluebird.default.bind({\n        failed: false,\n        failedOn: 0\n      });\n\n      var log = [];\n      (0, _lodash.each)(migrations, function (migration) {\n        var name = _this7.config.migrationSource.getMigrationName(migration);\n\n        _this7._activeMigration.fileName = name;\n\n        var migrationContent = _this7.config.migrationSource.getMigration(migration); // We're going to run each of the migrations in the current \"up\".\n\n\n        current = current.then(function () {\n          _this7._activeMigration.fileName = name;\n\n          if (!trx && _this7._useTransaction(migrationContent, disableTransactions)) {\n            _this7.knex.enableProcessing();\n\n            return _this7._transaction(_this7.knex, migrationContent, direction, name);\n          }\n\n          trxOrKnex.enableProcessing();\n          return checkPromise(_this7.knex.client.logger, migrationContent[direction](trxOrKnex, _bluebird.default), name);\n        }).then(function () {\n          trxOrKnex.disableProcessing();\n\n          _this7.knex.disableProcessing();\n\n          log.push(name);\n\n          if (direction === 'up') {\n            return trxOrKnex.into((0, _tableResolver.getTableName)(tableName, schemaName)).insert({\n              name: name,\n              batch: batchNo,\n              migration_time: new Date()\n            });\n          }\n\n          if (direction === 'down') {\n            return trxOrKnex.from((0, _tableResolver.getTableName)(tableName, schemaName)).where({\n              name: name\n            }).del();\n          }\n        });\n      });\n      return current.thenReturn([batchNo, log]);\n    }\n  }, {\n    key: \"_transaction\",\n    value: function _transaction(knex, migrationContent, direction, name) {\n      return knex.transaction(function (trx) {\n        return checkPromise(knex.client.logger, migrationContent[direction](trx, _bluebird.default), name, function () {\n          trx.commit();\n        });\n      });\n    }\n  }]);\n\n  return Migrator;\n}();\n\nexports.default = Migrator;\n\nfunction getMergedConfig(config, currentConfig) {\n  // config is the user specified config, mergedConfig has defaults and current config\n  // applied to it.\n  var mergedConfig = (0, _lodash.assign)({}, CONFIG_DEFAULT, currentConfig || {}, config);\n\n  if (config && ( // If user specifies any FS related config,\n  // clear existing FsMigrations migrationSource\n  config.directory || config.sortDirsSeparately !== undefined || config.loadExtensions)) {\n    mergedConfig.migrationSource = null;\n  } // If the user has not specified any configs, we need to\n  // default to fs migrations to maintain compatibility\n\n\n  if (!mergedConfig.migrationSource) {\n    mergedConfig.migrationSource = new _fsMigrations.default(mergedConfig.directory, mergedConfig.sortDirsSeparately);\n  }\n\n  return mergedConfig;\n} // Validates that migrations are present in the appropriate directories.\n\n\nfunction validateMigrationList(migrationSource, migrations) {\n  var all = migrations[0];\n  var completed = migrations[1];\n  var diff = getMissingMigrations(migrationSource, completed, all);\n\n  if (!(0, _lodash.isEmpty)(diff)) {\n    throw new Error(\"The migration directory is corrupt, the following files are missing: \".concat(diff.join(', ')));\n  }\n}\n\nfunction getMissingMigrations(migrationSource, completed, all) {\n  return (0, _lodash.differenceWith)(completed, all, function (completedMigration, allMigration) {\n    return completedMigration === migrationSource.getMigrationName(allMigration);\n  });\n}\n\nfunction getNewMigrations(migrationSource, all, completed) {\n  return (0, _lodash.differenceWith)(all, completed, function (allMigration, completedMigration) {\n    return completedMigration === migrationSource.getMigrationName(allMigration);\n  });\n}\n\nfunction checkPromise(logger, migrationPromise, name, commitFn) {\n  if (!migrationPromise || typeof migrationPromise.then !== 'function') {\n    logger.warn(\"migration \".concat(name, \" did not return a promise\"));\n\n    if (commitFn) {\n      commitFn();\n    }\n  }\n\n  return migrationPromise;\n}","map":null,"metadata":{},"sourceType":"script"}