{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _inherits = _interopRequireDefault(require(\"inherits\"));\n\nvar _compiler = _interopRequireDefault(require(\"../../../query/compiler\"));\n\nvar _lodash = require(\"lodash\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // MSSQL Query Compiler\n// ------\n\n\nfunction QueryCompiler_MSSQL(client, builder) {\n  _compiler.default.call(this, client, builder);\n}\n\n(0, _inherits.default)(QueryCompiler_MSSQL, _compiler.default);\nvar components = ['columns', 'join', 'lock', 'where', 'union', 'group', 'having', 'order', 'limit', 'offset'];\n(0, _lodash.assign)(QueryCompiler_MSSQL.prototype, {\n  _emptyInsertValue: 'default values',\n  select: function select() {\n    var _this = this;\n\n    var sql = this.with();\n    var statements = components.map(function (component) {\n      return _this[component](_this);\n    });\n    return sql + (0, _lodash.compact)(statements).join(' ');\n  },\n  // Compiles an \"insert\" query, allowing for multiple\n  // inserts using a single query statement.\n  insert: function insert() {\n    var insertValues = this.single.insert || [];\n    var sql = this.with() + \"insert into \".concat(this.tableName, \" \");\n    var returning = this.single.returning;\n    var returningSql = returning ? this._returning('insert', returning) + ' ' : '';\n\n    if (Array.isArray(insertValues)) {\n      if (insertValues.length === 0) {\n        return '';\n      }\n    } else if (typeof insertValues === 'object' && (0, _lodash.isEmpty)(insertValues)) {\n      return {\n        sql: sql + returningSql + this._emptyInsertValue,\n        returning: returning\n      };\n    }\n\n    var insertData = this._prepInsert(insertValues);\n\n    if (typeof insertData === 'string') {\n      sql += insertData;\n    } else {\n      if (insertData.columns.length) {\n        sql += \"(\".concat(this.formatter.columnize(insertData.columns));\n        sql += \") \".concat(returningSql, \"values (\");\n        var i = -1;\n\n        while (++i < insertData.values.length) {\n          if (i !== 0) sql += '), (';\n          sql += this.formatter.parameterize(insertData.values[i], this.client.valueForUndefined);\n        }\n\n        sql += ')';\n      } else if (insertValues.length === 1 && insertValues[0]) {\n        sql += returningSql + this._emptyInsertValue;\n      } else {\n        sql = '';\n      }\n    }\n\n    return {\n      sql: sql,\n      returning: returning\n    };\n  },\n  // Compiles an `update` query, allowing for a return value.\n  update: function update() {\n    var top = this.top();\n    var withSQL = this.with();\n\n    var updates = this._prepUpdate(this.single.update);\n\n    var join = this.join();\n    var where = this.where();\n    var order = this.order();\n    var returning = this.single.returning;\n    return {\n      sql: withSQL + \"update \".concat(top ? top + ' ' : '').concat(this.tableName) + ' set ' + updates.join(', ') + (returning ? \" \".concat(this._returning('update', returning)) : '') + (join ? \" from \".concat(this.tableName, \" \").concat(join) : '') + (where ? \" \".concat(where) : '') + (order ? \" \".concat(order) : '') + (!returning ? this._returning('rowcount', '@@rowcount') : ''),\n      returning: returning || '@@rowcount'\n    };\n  },\n  // Compiles a `delete` query.\n  del: function del() {\n    // Make sure tableName is processed by the formatter first.\n    var withSQL = this.with();\n    var tableName = this.tableName;\n    var wheres = this.where();\n    var returning = this.single.returning;\n    return {\n      sql: withSQL + \"delete from \".concat(tableName) + (returning ? \" \".concat(this._returning('del', returning)) : '') + (wheres ? \" \".concat(wheres) : '') + (!returning ? this._returning('rowcount', '@@rowcount') : ''),\n      returning: returning || '@@rowcount'\n    };\n  },\n  // Compiles the columns in the query, specifying if an item was distinct.\n  columns: function columns() {\n    var distinct = false;\n    if (this.onlyUnions()) return '';\n    var top = this.top();\n    var columns = this.grouped.columns || [];\n    var i = -1,\n        sql = [];\n\n    if (columns) {\n      while (++i < columns.length) {\n        var stmt = columns[i];\n        if (stmt.distinct) distinct = true;\n\n        if (stmt.type === 'aggregate') {\n          sql.push(this.aggregate(stmt));\n        } else if (stmt.type === 'aggregateRaw') {\n          sql.push(this.aggregateRaw(stmt));\n        } else if (stmt.value && stmt.value.length > 0) {\n          sql.push(this.formatter.columnize(stmt.value));\n        }\n      }\n    }\n\n    if (sql.length === 0) sql = ['*'];\n    return \"select \".concat(distinct ? 'distinct ' : '') + (top ? top + ' ' : '') + sql.join(', ') + (this.tableName ? \" from \".concat(this.tableName) : '');\n  },\n  _returning: function _returning(method, value) {\n    switch (method) {\n      case 'update':\n      case 'insert':\n        return value ? \"output \".concat(this.formatter.columnizeWithPrefix('inserted.', value)) : '';\n\n      case 'del':\n        return value ? \"output \".concat(this.formatter.columnizeWithPrefix('deleted.', value)) : '';\n\n      case 'rowcount':\n        return value ? ';select @@rowcount' : '';\n    }\n  },\n  // Compiles a `truncate` query.\n  truncate: function truncate() {\n    return \"truncate table \".concat(this.tableName);\n  },\n  forUpdate: function forUpdate() {\n    // this doesn't work exacltly as it should, one should also mention index while locking\n    // https://stackoverflow.com/a/9818448/360060\n    return 'with (UPDLOCK)';\n  },\n  forShare: function forShare() {\n    // http://www.sqlteam.com/article/introduction-to-locking-in-sql-server\n    return 'with (HOLDLOCK)';\n  },\n  // Compiles a `columnInfo` query.\n  columnInfo: function columnInfo() {\n    var column = this.single.columnInfo;\n    var schema = this.single.schema; // The user may have specified a custom wrapIdentifier function in the config. We\n    // need to run the identifiers through that function, but not format them as\n    // identifiers otherwise.\n\n    var table = this.client.customWrapIdentifier(this.single.table, _lodash.identity);\n\n    if (schema) {\n      schema = this.client.customWrapIdentifier(schema, _lodash.identity);\n    }\n\n    var sql = \"select * from information_schema.columns where table_name = ? and table_catalog = ?\";\n    var bindings = [table, this.client.database()];\n\n    if (schema) {\n      sql += ' and table_schema = ?';\n      bindings.push(schema);\n    } else {\n      sql += \" and table_schema = 'dbo'\";\n    }\n\n    return {\n      sql: sql,\n      bindings: bindings,\n      output: function output(resp) {\n        var out = resp.reduce(function (columns, val) {\n          columns[val.COLUMN_NAME] = {\n            defaultValue: val.COLUMN_DEFAULT,\n            type: val.DATA_TYPE,\n            maxLength: val.CHARACTER_MAXIMUM_LENGTH,\n            nullable: val.IS_NULLABLE === 'YES'\n          };\n          return columns;\n        }, {});\n        return column && out[column] || out;\n      }\n    };\n  },\n  top: function top() {\n    var noLimit = !this.single.limit && this.single.limit !== 0;\n    var noOffset = !this.single.offset;\n    if (noLimit || !noOffset) return '';\n    return \"top (\".concat(this.formatter.parameter(this.single.limit), \")\");\n  },\n  limit: function limit() {\n    return '';\n  },\n  offset: function offset() {\n    var noLimit = !this.single.limit && this.single.limit !== 0;\n    var noOffset = !this.single.offset;\n    if (noOffset) return '';\n    var offset = \"offset \".concat(noOffset ? '0' : this.formatter.parameter(this.single.offset), \" rows\");\n\n    if (!noLimit) {\n      offset += \" fetch next \".concat(this.formatter.parameter(this.single.limit), \" rows only\");\n    }\n\n    return offset;\n  }\n}); // Set the QueryBuilder & QueryCompiler on the client object,\n// in case anyone wants to modify things to suit their own purposes.\n\nvar _default = QueryCompiler_MSSQL;\nexports.default = _default;\nmodule.exports = exports.default;","map":null,"metadata":{},"sourceType":"script"}