{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _lodash = require(\"lodash\");\n\nvar _assert = _interopRequireDefault(require(\"assert\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // JoinClause\n// -------\n// The \"JoinClause\" is an object holding any necessary info about a join,\n// including the type, and any associated tables & columns being joined.\n\n\nfunction JoinClause(table, type, schema) {\n  this.schema = schema;\n  this.table = table;\n  this.joinType = type;\n  this.and = this;\n  this.clauses = [];\n}\n\nfunction getClauseFromArguments(compilerType, bool, first, operator, second) {\n  var data = null;\n\n  if (typeof first === 'function') {\n    data = {\n      type: 'onWrapped',\n      value: first,\n      bool: bool\n    };\n  } else {\n    switch (arguments.length) {\n      case 3:\n        {\n          data = {\n            type: 'onRaw',\n            value: first,\n            bool: bool\n          };\n          break;\n        }\n\n      case 4:\n        data = {\n          type: compilerType,\n          column: first,\n          operator: '=',\n          value: operator,\n          bool: bool\n        };\n        break;\n\n      default:\n        data = {\n          type: compilerType,\n          column: first,\n          operator: operator,\n          value: second,\n          bool: bool\n        };\n    }\n  }\n\n  return data;\n}\n\n(0, _lodash.assign)(JoinClause.prototype, {\n  grouping: 'join',\n  // Adds an \"on\" clause to the current join object.\n  on: function on(first) {\n    if (typeof first === 'object' && typeof first.toSQL !== 'function') {\n      var keys = Object.keys(first);\n      var i = -1;\n      var method = this._bool() === 'or' ? 'orOn' : 'on';\n\n      while (++i < keys.length) {\n        this[method](keys[i], first[keys[i]]);\n      }\n\n      return this;\n    }\n\n    var data = getClauseFromArguments.apply(void 0, ['onBasic', this._bool()].concat(Array.prototype.slice.call(arguments)));\n\n    if (data) {\n      this.clauses.push(data);\n    }\n\n    return this;\n  },\n  // Adds a \"using\" clause to the current join.\n  using: function using(column) {\n    return this.clauses.push({\n      type: 'onUsing',\n      column: column,\n      bool: this._bool()\n    });\n  },\n\n  /*// Adds an \"and on\" clause to the current join object.\n  andOn() {\n    return this.on.apply(this, arguments);\n  },*/\n  // Adds an \"or on\" clause to the current join object.\n  orOn: function orOn(first, operator, second) {\n    return this._bool('or').on.apply(this, arguments);\n  },\n  onVal: function onVal(first) {\n    if (typeof first === 'object' && typeof first.toSQL !== 'function') {\n      var keys = Object.keys(first);\n      var i = -1;\n      var method = this._bool() === 'or' ? 'orOnVal' : 'onVal';\n\n      while (++i < keys.length) {\n        this[method](keys[i], first[keys[i]]);\n      }\n\n      return this;\n    }\n\n    var data = getClauseFromArguments.apply(void 0, ['onVal', this._bool()].concat(Array.prototype.slice.call(arguments)));\n\n    if (data) {\n      this.clauses.push(data);\n    }\n\n    return this;\n  },\n  andOnVal: function andOnVal() {\n    return this.onVal.apply(this, arguments);\n  },\n  orOnVal: function orOnVal() {\n    var _this$_bool;\n\n    return (_this$_bool = this._bool('or')).onVal.apply(_this$_bool, arguments);\n  },\n  onBetween: function onBetween(column, values) {\n    (0, _assert.default)(Array.isArray(values), 'The second argument to onBetween must be an array.');\n    (0, _assert.default)(values.length === 2, 'You must specify 2 values for the onBetween clause');\n    this.clauses.push({\n      type: 'onBetween',\n      column: column,\n      value: values,\n      bool: this._bool(),\n      not: this._not()\n    });\n    return this;\n  },\n  onNotBetween: function onNotBetween(column, values) {\n    return this._not(true).onBetween(column, values);\n  },\n  orOnBetween: function orOnBetween(column, values) {\n    return this._bool('or').onBetween(column, values);\n  },\n  orOnNotBetween: function orOnNotBetween(column, values) {\n    return this._bool('or')._not(true).onBetween(column, values);\n  },\n  onIn: function onIn(column, values) {\n    if (Array.isArray(values) && values.length === 0) return this.on(1, '=', 0);\n    this.clauses.push({\n      type: 'onIn',\n      column: column,\n      value: values,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  },\n  onNotIn: function onNotIn(column, values) {\n    return this._not(true).onIn(column, values);\n  },\n  orOnIn: function orOnIn(column, values) {\n    return this._bool('or').onIn(column, values);\n  },\n  orOnNotIn: function orOnNotIn(column, values) {\n    return this._bool('or')._not(true).onIn(column, values);\n  },\n  onNull: function onNull(column) {\n    this.clauses.push({\n      type: 'onNull',\n      column: column,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  },\n  orOnNull: function orOnNull(callback) {\n    return this._bool('or').onNull(callback);\n  },\n  onNotNull: function onNotNull(callback) {\n    return this._not(true).onNull(callback);\n  },\n  orOnNotNull: function orOnNotNull(callback) {\n    return this._not(true)._bool('or').onNull(callback);\n  },\n  onExists: function onExists(callback) {\n    this.clauses.push({\n      type: 'onExists',\n      value: callback,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  },\n  orOnExists: function orOnExists(callback) {\n    return this._bool('or').onExists(callback);\n  },\n  onNotExists: function onNotExists(callback) {\n    return this._not(true).onExists(callback);\n  },\n  orOnNotExists: function orOnNotExists(callback) {\n    return this._not(true)._bool('or').onExists(callback);\n  },\n  // Explicitly set the type of join, useful within a function when creating a grouped join.\n  type: function type(_type) {\n    this.joinType = _type;\n    return this;\n  },\n  _bool: function _bool(bool) {\n    if (arguments.length === 1) {\n      this._boolFlag = bool;\n      return this;\n    }\n\n    var ret = this._boolFlag || 'and';\n    this._boolFlag = 'and';\n    return ret;\n  },\n  _not: function _not(val) {\n    if (arguments.length === 1) {\n      this._notFlag = val;\n      return this;\n    }\n\n    var ret = this._notFlag;\n    this._notFlag = false;\n    return ret;\n  }\n});\nObject.defineProperty(JoinClause.prototype, 'or', {\n  get: function get() {\n    return this._bool('or');\n  }\n});\nJoinClause.prototype.andOn = JoinClause.prototype.on;\nJoinClause.prototype.andOnIn = JoinClause.prototype.onIn;\nJoinClause.prototype.andOnNotIn = JoinClause.prototype.onNotIn;\nJoinClause.prototype.andOnNull = JoinClause.prototype.onNull;\nJoinClause.prototype.andOnNotNull = JoinClause.prototype.onNotNull;\nJoinClause.prototype.andOnExists = JoinClause.prototype.onExists;\nJoinClause.prototype.andOnNotExists = JoinClause.prototype.onNotExists;\nJoinClause.prototype.andOnBetween = JoinClause.prototype.onBetween;\nJoinClause.prototype.andOnNotBetween = JoinClause.prototype.onNotBetween;\nvar _default = JoinClause;\nexports.default = _default;\nmodule.exports = exports.default;","map":null,"metadata":{},"sourceType":"script"}