{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _inherits = _interopRequireDefault(require(\"inherits\"));\n\nvar helpers = _interopRequireWildcard(require(\"./helpers\"));\n\nvar _events = require(\"events\");\n\nvar _debug = _interopRequireDefault(require(\"debug\"));\n\nvar _lodash = require(\"lodash\");\n\nvar _saveAsyncStack = _interopRequireDefault(require(\"./util/save-async-stack\"));\n\nvar _uuid = _interopRequireDefault(require(\"uuid\"));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // Raw\n// -------\n\n\nvar debugBindings = (0, _debug.default)('knex:bindings');\n\nfunction Raw(client) {\n  this.client = client;\n  this.sql = '';\n  this.bindings = []; // Todo: Deprecate\n\n  this._wrappedBefore = undefined;\n  this._wrappedAfter = undefined;\n\n  if (client && client.config) {\n    this._debug = client.config.debug;\n    (0, _saveAsyncStack.default)(this, 4);\n  }\n}\n\n(0, _inherits.default)(Raw, _events.EventEmitter);\n(0, _lodash.assign)(Raw.prototype, {\n  set: function set(sql, bindings) {\n    this.sql = sql;\n    this.bindings = (0, _lodash.isObject)(bindings) && !bindings.toSQL || (0, _lodash.isUndefined)(bindings) ? bindings : [bindings];\n    return this;\n  },\n  timeout: function timeout(ms) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        cancel = _ref.cancel;\n\n    if ((0, _lodash.isNumber)(ms) && ms > 0) {\n      this._timeout = ms;\n\n      if (cancel) {\n        this.client.assertCanCancelQuery();\n        this._cancelOnTimeout = true;\n      }\n    }\n\n    return this;\n  },\n  // Wraps the current sql with `before` and `after`.\n  wrap: function wrap(before, after) {\n    this._wrappedBefore = before;\n    this._wrappedAfter = after;\n    return this;\n  },\n  // Calls `toString` on the Knex object.\n  toString: function toString() {\n    return this.toQuery();\n  },\n  // Returns the raw sql for the query.\n  toSQL: function toSQL(method, tz) {\n    var obj;\n    var formatter = this.client.formatter(this);\n\n    if (Array.isArray(this.bindings)) {\n      obj = replaceRawArrBindings(this, formatter);\n    } else if (this.bindings && (0, _lodash.isPlainObject)(this.bindings)) {\n      obj = replaceKeyBindings(this, formatter);\n    } else {\n      obj = {\n        method: 'raw',\n        sql: this.sql,\n        bindings: (0, _lodash.isUndefined)(this.bindings) ? [] : [this.bindings]\n      };\n    }\n\n    if (this._wrappedBefore) {\n      obj.sql = this._wrappedBefore + obj.sql;\n    }\n\n    if (this._wrappedAfter) {\n      obj.sql = obj.sql + this._wrappedAfter;\n    }\n\n    obj.options = (0, _lodash.reduce)(this._options, _lodash.assign, {});\n\n    if (this._timeout) {\n      obj.timeout = this._timeout;\n\n      if (this._cancelOnTimeout) {\n        obj.cancelOnTimeout = this._cancelOnTimeout;\n      }\n    }\n\n    obj.bindings = obj.bindings || [];\n\n    if (helpers.containsUndefined(obj.bindings)) {\n      debugBindings(obj.bindings);\n      throw new Error(\"Undefined binding(s) detected when compiling RAW query: \" + obj.sql);\n    }\n\n    obj.__knexQueryUid = _uuid.default.v4();\n    return obj;\n  }\n});\n\nfunction replaceRawArrBindings(raw, formatter) {\n  var expectedBindings = raw.bindings.length;\n  var values = raw.bindings;\n  var index = 0;\n  var sql = raw.sql.replace(/\\\\?\\?\\??/g, function (match) {\n    if (match === '\\\\?') {\n      return match;\n    }\n\n    var value = values[index++];\n\n    if (match === '??') {\n      return formatter.columnize(value);\n    }\n\n    return formatter.parameter(value);\n  });\n\n  if (expectedBindings !== index) {\n    throw new Error(\"Expected \".concat(expectedBindings, \" bindings, saw \").concat(index));\n  }\n\n  return {\n    method: 'raw',\n    sql: sql,\n    bindings: formatter.bindings\n  };\n}\n\nfunction replaceKeyBindings(raw, formatter) {\n  var values = raw.bindings;\n  var regex = /\\\\?(:(\\w+):(?=::)|:(\\w+):(?!:)|:(\\w+))/g;\n  var sql = raw.sql.replace(regex, function (match, p1, p2, p3, p4) {\n    if (match !== p1) {\n      return p1;\n    }\n\n    var part = p2 || p3 || p4;\n    var key = match.trim();\n    var isIdentifier = key[key.length - 1] === ':';\n    var value = values[part];\n\n    if (value === undefined) {\n      if (values.hasOwnProperty(part)) {\n        formatter.bindings.push(value);\n      }\n\n      return match;\n    }\n\n    if (isIdentifier) {\n      return match.replace(p1, formatter.columnize(value));\n    }\n\n    return match.replace(p1, formatter.parameter(value));\n  });\n  return {\n    method: 'raw',\n    sql: sql,\n    bindings: formatter.bindings\n  };\n} // Allow the `Raw` object to be utilized with full access to the relevant\n// promise API.\n\n\nrequire('./interface')(Raw);\n\nhelpers.addQueryContext(Raw);\nvar _default = Raw;\nexports.default = _default;\nmodule.exports = exports.default;","map":null,"metadata":{},"sourceType":"script"}