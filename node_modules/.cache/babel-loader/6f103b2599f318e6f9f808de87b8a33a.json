{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _inherits = _interopRequireDefault(require(\"inherits\"));\n\nvar _compiler = _interopRequireDefault(require(\"../../../query/compiler\"));\n\nvar _compiler2 = _interopRequireDefault(require(\"../../postgres/query/compiler\"));\n\nvar _lodash = require(\"lodash\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // Redshift Query Builder & Compiler\n// ------\n\n\nfunction QueryCompiler_Redshift(client, builder) {\n  _compiler2.default.call(this, client, builder);\n}\n\n(0, _inherits.default)(QueryCompiler_Redshift, _compiler2.default);\n(0, _lodash.assign)(QueryCompiler_Redshift.prototype, {\n  truncate: function truncate() {\n    return \"truncate \".concat(this.tableName.toLowerCase());\n  },\n  // Compiles an `insert` query, allowing for multiple\n  // inserts using a single query statement.\n  insert: function insert() {\n    var sql = _compiler.default.prototype.insert.apply(this, arguments);\n\n    if (sql === '') return sql;\n\n    this._slightReturn();\n\n    return {\n      sql: sql\n    };\n  },\n  // Compiles an `update` query, warning on unsupported returning\n  update: function update() {\n    var sql = _compiler.default.prototype.update.apply(this, arguments);\n\n    this._slightReturn();\n\n    return {\n      sql: sql\n    };\n  },\n  // Compiles an `delete` query, warning on unsupported returning\n  del: function del() {\n    var sql = _compiler.default.prototype.del.apply(this, arguments);\n\n    this._slightReturn();\n\n    return {\n      sql: sql\n    };\n  },\n  // simple: if trying to return, warn\n  _slightReturn: function _slightReturn() {\n    if (this.single.isReturning) {\n      this.client.logger.warn('insert/update/delete returning is not supported by redshift dialect');\n    }\n  },\n  forUpdate: function forUpdate() {\n    this.client.logger.warn('table lock is not supported by redshift dialect');\n    return '';\n  },\n  forShare: function forShare() {\n    this.client.logger.warn('lock for share is not supported by redshift dialect');\n    return '';\n  },\n  // Compiles a columnInfo query\n  columnInfo: function columnInfo() {\n    var column = this.single.columnInfo;\n    var schema = this.single.schema; // The user may have specified a custom wrapIdentifier function in the config. We\n    // need to run the identifiers through that function, but not format them as\n    // identifiers otherwise.\n\n    var table = this.client.customWrapIdentifier(this.single.table, _lodash.identity);\n\n    if (schema) {\n      schema = this.client.customWrapIdentifier(schema, _lodash.identity);\n    }\n\n    var sql = 'select * from information_schema.columns where table_name = ? and table_catalog = ?';\n    var bindings = [table.toLowerCase(), this.client.database().toLowerCase()];\n\n    if (schema) {\n      sql += ' and table_schema = ?';\n      bindings.push(schema);\n    } else {\n      sql += ' and table_schema = current_schema()';\n    }\n\n    return {\n      sql: sql,\n      bindings: bindings,\n      output: function output(resp) {\n        var out = (0, _lodash.reduce)(resp.rows, function (columns, val) {\n          columns[val.column_name] = {\n            type: val.data_type,\n            maxLength: val.character_maximum_length,\n            nullable: val.is_nullable === 'YES',\n            defaultValue: val.column_default\n          };\n          return columns;\n        }, {});\n        return column && out[column] || out;\n      }\n    };\n  }\n});\nvar _default = QueryCompiler_Redshift;\nexports.default = _default;\nmodule.exports = exports.default;","map":null,"metadata":{},"sourceType":"script"}