{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits2 = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _construct = require(\"/Users/phill/Documents/RMIT/2019Sem1/COSC2408/JPLCarShare/node_modules/@babel/runtime/helpers/construct\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _lodash = require(\"lodash\");\n\nvar _inherits = _interopRequireDefault(require(\"inherits\"));\n\nvar _client = _interopRequireDefault(require(\"../../client\"));\n\nvar _bluebird = _interopRequireDefault(require(\"bluebird\"));\n\nvar _formatter = _interopRequireDefault(require(\"../../formatter\"));\n\nvar _transaction = _interopRequireDefault(require(\"./transaction\"));\n\nvar _compiler = _interopRequireDefault(require(\"./query/compiler\"));\n\nvar _compiler2 = _interopRequireDefault(require(\"./schema/compiler\"));\n\nvar _tablecompiler = _interopRequireDefault(require(\"./schema/tablecompiler\"));\n\nvar _columncompiler = _interopRequireDefault(require(\"./schema/columncompiler\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nvar isArray = Array.isArray;\nvar SQL_INT4 = {\n  MIN: -2147483648,\n  MAX: 2147483647\n};\nvar SQL_BIGINT_SAFE = {\n  MIN: -9007199254740991,\n  MAX: 9007199254740991\n}; // Always initialize with the \"QueryBuilder\" and \"QueryCompiler\" objects, which\n// extend the base 'lib/query/builder' and 'lib/query/compiler', respectively.\n\nfunction Client_MSSQL() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  // #1235 mssql module wants 'server', not 'host'. This is to enforce the same\n  // options object across all dialects.\n  if (config && config.connection && config.connection.host) {\n    config.connection.server = config.connection.host;\n  } // mssql always creates pool :( lets try to unpool it as much as possible\n\n\n  this.mssqlPoolSettings = {\n    min: 1,\n    max: 1,\n    idleTimeoutMillis: Number.MAX_SAFE_INTEGER,\n    evictionRunIntervalMillis: 0\n  };\n\n  _client.default.call(this, config);\n}\n\n(0, _inherits.default)(Client_MSSQL, _client.default);\n(0, _lodash.assign)(Client_MSSQL.prototype, {\n  dialect: 'mssql',\n  driverName: 'mssql',\n  _driver: function _driver() {\n    var tds = require('tedious');\n\n    var mssqlTedious = require('mssql');\n\n    var base = require('mssql/lib/base'); // Monkey patch mssql's tedious driver _poolCreate method to fix problem with hanging acquire\n    // connection, this should be removed when https://github.com/tediousjs/node-mssql/pull/614 is\n    // merged and released.\n    // Also since this dialect actually always uses tedious driver (msnodesqlv8 driver should be\n    // required in different way), it might be better to use tedious directly, because mssql\n    // driver uses always internally extra generic-pool and just adds one unnecessary layer of\n    // indirection between database and knex and mssql driver has been lately without maintainer\n    // (changing implementation to use tedious will be breaking change though).\n    // TODO: remove mssql implementation all together and use tedious directly\n\n    /* istanbul ignore next */\n\n\n    var mssqlVersion = require('mssql/package.json').version;\n    /* istanbul ignore next */\n\n\n    if (mssqlVersion === '4.1.0') {\n      mssqlTedious.ConnectionPool.prototype.release = release;\n      mssqlTedious.ConnectionPool.prototype._poolCreate = _poolCreate;\n    } else {\n      var _mssqlVersion$split = mssqlVersion.split('.'),\n          _mssqlVersion$split2 = _slicedToArray(_mssqlVersion$split, 1),\n          major = _mssqlVersion$split2[0]; // if version is not ^5.0.0\n\n\n      if (major < 5) {\n        throw new Error('This knex version only supports mssql driver versions 4.1.0 and 5.0.0+');\n      }\n    }\n    /* istanbul ignore next */\n    // in some rare situations release is called when stream is interrupted, but\n    // after pool is already destroyed\n\n\n    function release(connection) {\n      if (this.pool) {\n        this.pool.release(connection);\n      }\n    }\n    /* istanbul ignore next */\n\n\n    function _poolCreate() {\n      var _this = this;\n\n      // implementation is copy-pasted from https://github.com/tediousjs/node-mssql/pull/614\n      return new base.Promise(function (resolve, reject) {\n        var cfg = {\n          userName: _this.config.user,\n          password: _this.config.password,\n          server: _this.config.server,\n          options: Object.assign({}, _this.config.options),\n          domain: _this.config.domain\n        };\n        cfg.options.database = _this.config.database;\n        cfg.options.port = _this.config.port;\n        cfg.options.connectTimeout = _this.config.connectionTimeout || _this.config.timeout || 15000;\n        cfg.options.requestTimeout = _this.config.requestTimeout != null ? _this.config.requestTimeout : 15000;\n        cfg.options.tdsVersion = cfg.options.tdsVersion || '7_4';\n        cfg.options.rowCollectionOnDone = false;\n        cfg.options.rowCollectionOnRequestCompletion = false;\n        cfg.options.useColumnNames = false;\n        cfg.options.appName = cfg.options.appName || 'node-mssql'; // tedious always connect via tcp when port is specified\n\n        if (cfg.options.instanceName) delete cfg.options.port;\n        if (isNaN(cfg.options.requestTimeout)) cfg.options.requestTimeout = 15000;\n        if (cfg.options.requestTimeout === Infinity) cfg.options.requestTimeout = 0;\n        if (cfg.options.requestTimeout < 0) cfg.options.requestTimeout = 0;\n\n        if (_this.config.debug) {\n          cfg.options.debug = {\n            packet: true,\n            token: true,\n            data: true,\n            payload: true\n          };\n        }\n\n        var tedious = new tds.Connection(cfg); // prevent calling resolve again on end event\n\n        var alreadyResolved = false;\n\n        function safeResolve(err) {\n          if (!alreadyResolved) {\n            alreadyResolved = true;\n            resolve(err);\n          }\n        }\n\n        function safeReject(err) {\n          if (!alreadyResolved) {\n            alreadyResolved = true;\n            reject(err);\n          }\n        }\n\n        tedious.once('end', function (evt) {\n          safeReject(new base.ConnectionError('Connection ended unexpectedly during connecting'));\n        });\n        tedious.once('connect', function (err) {\n          if (err) {\n            err = new base.ConnectionError(err);\n            return safeReject(err);\n          }\n\n          safeResolve(tedious);\n        });\n        tedious.on('error', function (err) {\n          if (err.code === 'ESOCKET') {\n            tedious.hasError = true;\n            return;\n          }\n\n          _this.emit('error', err);\n        });\n\n        if (_this.config.debug) {\n          tedious.on('debug', _this.emit.bind(_this, 'debug', tedious));\n        }\n      });\n    }\n\n    return mssqlTedious;\n  },\n  formatter: function formatter() {\n    return _construct(MSSQL_Formatter, [this].concat(Array.prototype.slice.call(arguments)));\n  },\n  transaction: function transaction() {\n    return _construct(_transaction.default, [this].concat(Array.prototype.slice.call(arguments)));\n  },\n  queryCompiler: function queryCompiler() {\n    return _construct(_compiler.default, [this].concat(Array.prototype.slice.call(arguments)));\n  },\n  schemaCompiler: function schemaCompiler() {\n    return _construct(_compiler2.default, [this].concat(Array.prototype.slice.call(arguments)));\n  },\n  tableCompiler: function tableCompiler() {\n    return _construct(_tablecompiler.default, [this].concat(Array.prototype.slice.call(arguments)));\n  },\n  columnCompiler: function columnCompiler() {\n    return _construct(_columncompiler.default, [this].concat(Array.prototype.slice.call(arguments)));\n  },\n  wrapIdentifierImpl: function wrapIdentifierImpl(value) {\n    return value !== '*' ? \"[\".concat(value.replace(/\\[/g, '['), \"]\") : '*';\n  },\n  // Get a raw connection, called by the `pool` whenever a new\n  // connection needs to be added to the pool.\n  acquireRawConnection: function acquireRawConnection() {\n    var _this2 = this;\n\n    return new _bluebird.default(function (resolver, rejecter) {\n      var settings = Object.assign({}, _this2.connectionSettings);\n      settings.pool = _this2.mssqlPoolSettings;\n      var connection = new _this2.driver.ConnectionPool(settings);\n      connection.connect(function (err) {\n        if (err) {\n          return rejecter(err);\n        }\n\n        connection.on('error', function (err) {\n          connection.__knex__disposed = err;\n        });\n        resolver(connection);\n      });\n    });\n  },\n  validateConnection: function validateConnection(connection) {\n    if (connection.connected === true) {\n      return true;\n    }\n\n    return false;\n  },\n  // Used to explicitly close a connection, called internally by the pool\n  // when a connection times out or the pool is shutdown.\n  destroyRawConnection: function destroyRawConnection(connection) {\n    return connection.close().catch(function (err) {// some times close will reject just because pool has already been destoyed\n      // internally by the driver there is nothing we can do in this case\n    });\n  },\n  // Position the bindings for the query.\n  positionBindings: function positionBindings(sql) {\n    var questionCount = -1;\n    return sql.replace(/\\?/g, function () {\n      questionCount += 1;\n      return \"@p\".concat(questionCount);\n    });\n  },\n  // Grab a connection, run the query via the MSSQL streaming interface,\n  // and pass that through to the stream we've sent back to the client.\n  _stream: function _stream(connection, obj, stream) {\n    var _this3 = this;\n\n    if (!obj || typeof obj === 'string') obj = {\n      sql: obj\n    };\n    return new _bluebird.default(function (resolver, rejecter) {\n      stream.on('error', function (err) {\n        rejecter(err);\n      });\n      stream.on('end', resolver);\n      var _obj = obj,\n          sql = _obj.sql;\n      if (!sql) return resolver();\n      var req = (connection.tx_ || connection).request(); //req.verbose = true;\n\n      req.multiple = true;\n      req.stream = true;\n\n      if (obj.bindings) {\n        for (var i = 0; i < obj.bindings.length; i++) {\n          _this3._setReqInput(req, i, obj.bindings[i]);\n        }\n      }\n\n      req.pipe(stream);\n      req.query(sql);\n    });\n  },\n  // Runs the query on the specified connection, providing the bindings\n  // and any other necessary prep work.\n  _query: function _query(connection, obj) {\n    var client = this;\n    if (!obj || typeof obj === 'string') obj = {\n      sql: obj\n    };\n    return new _bluebird.default(function (resolver, rejecter) {\n      var _obj2 = obj,\n          sql = _obj2.sql;\n      if (!sql) return resolver();\n      var req = (connection.tx_ || connection).request(); // req.verbose = true;\n\n      req.multiple = true;\n\n      if (obj.bindings) {\n        for (var i = 0; i < obj.bindings.length; i++) {\n          client._setReqInput(req, i, obj.bindings[i]);\n        }\n      }\n\n      req.query(sql, function (err, recordset) {\n        if (err) {\n          return rejecter(err);\n        }\n\n        obj.response = recordset.recordsets[0];\n        resolver(obj);\n      });\n    });\n  },\n  // sets a request input parameter. Detects bigints and decimals and sets type appropriately.\n  _setReqInput: function _setReqInput(req, i, binding) {\n    if (typeof binding == 'number') {\n      if (binding % 1 !== 0) {\n        req.input(\"p\".concat(i), this.driver.Decimal(38, 10), binding);\n      } else if (binding < SQL_INT4.MIN || binding > SQL_INT4.MAX) {\n        if (binding < SQL_BIGINT_SAFE.MIN || binding > SQL_BIGINT_SAFE.MAX) {\n          throw new Error(\"Bigint must be safe integer or must be passed as string, saw \".concat(binding));\n        }\n\n        req.input(\"p\".concat(i), this.driver.BigInt, binding);\n      } else {\n        req.input(\"p\".concat(i), this.driver.Int, binding);\n      }\n    } else {\n      req.input(\"p\".concat(i), binding);\n    }\n  },\n  // Process the response as returned from the query.\n  processResponse: function processResponse(obj, runner) {\n    if (obj == null) return;\n    var response = obj.response,\n        method = obj.method;\n    if (obj.output) return obj.output.call(runner, response);\n\n    switch (method) {\n      case 'select':\n      case 'pluck':\n      case 'first':\n        if (method === 'pluck') return (0, _lodash.map)(response, obj.pluck);\n        return method === 'first' ? response[0] : response;\n\n      case 'insert':\n      case 'del':\n      case 'update':\n      case 'counter':\n        if (obj.returning) {\n          if (obj.returning === '@@rowcount') {\n            return response[0][''];\n          }\n\n          if (isArray(obj.returning) && obj.returning.length > 1 || obj.returning[0] === '*') {\n            return response;\n          } // return an array with values if only one returning value was specified\n\n\n          return (0, _lodash.flatten)((0, _lodash.map)(response, _lodash.values));\n        }\n\n        return response;\n\n      default:\n        return response;\n    }\n  }\n});\n\nvar MSSQL_Formatter =\n/*#__PURE__*/\nfunction (_formatter$default) {\n  _inherits2(MSSQL_Formatter, _formatter$default);\n\n  function MSSQL_Formatter() {\n    _classCallCheck(this, MSSQL_Formatter);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(MSSQL_Formatter).apply(this, arguments));\n  }\n\n  _createClass(MSSQL_Formatter, [{\n    key: \"columnizeWithPrefix\",\n    // Accepts a string or array of columns to wrap as appropriate.\n    value: function columnizeWithPrefix(prefix, target) {\n      var columns = typeof target === 'string' ? [target] : target;\n      var str = '',\n          i = -1;\n\n      while (++i < columns.length) {\n        if (i > 0) str += ', ';\n        str += prefix + this.wrap(columns[i]);\n      }\n\n      return str;\n    }\n  }]);\n\n  return MSSQL_Formatter;\n}(_formatter.default);\n\nvar _default = Client_MSSQL;\nexports.default = _default;\nmodule.exports = exports.default;","map":null,"metadata":{},"sourceType":"script"}