{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _helpers = require(\"./helpers\");\n\nvar helpers = _interopRequireWildcard(require(\"../helpers\"));\n\nvar _lodash = require(\"lodash\");\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n/* eslint max-len:0 */\n// Table Compiler\n// -------\n\n\nfunction TableCompiler(client, tableBuilder) {\n  this.client = client;\n  this.tableBuilder = tableBuilder;\n  this._commonBuilder = this.tableBuilder;\n  this.method = tableBuilder._method;\n  this.schemaNameRaw = tableBuilder._schemaName;\n  this.tableNameRaw = tableBuilder._tableName;\n  this.single = tableBuilder._single;\n  this.grouped = (0, _lodash.groupBy)(tableBuilder._statements, 'grouping');\n  this.formatter = client.formatter(tableBuilder);\n  this.sequence = [];\n  this._formatting = client.config && client.config.formatting;\n}\n\nTableCompiler.prototype.pushQuery = _helpers.pushQuery;\nTableCompiler.prototype.pushAdditional = _helpers.pushAdditional;\nTableCompiler.prototype.unshiftQuery = _helpers.unshiftQuery; // Convert the tableCompiler toSQL\n\nTableCompiler.prototype.toSQL = function () {\n  this[this.method]();\n  return this.sequence;\n};\n\nTableCompiler.prototype.lowerCase = true; // Column Compilation\n// -------\n// If this is a table \"creation\", we need to first run through all\n// of the columns to build them into a single string,\n// and then run through anything else and push it to the query sequence.\n\nTableCompiler.prototype.createAlterTableMethods = null;\n\nTableCompiler.prototype.create = function (ifNot) {\n  var columnBuilders = this.getColumns();\n  var columns = columnBuilders.map(function (col) {\n    return col.toSQL();\n  });\n  var columnTypes = this.getColumnTypes(columns);\n\n  if (this.createAlterTableMethods) {\n    this.alterTableForCreate(columnTypes);\n  }\n\n  this.createQuery(columnTypes, ifNot);\n  this.columnQueries(columns);\n  delete this.single.comment;\n  this.alterTable();\n}; // Only create the table if it doesn't exist.\n\n\nTableCompiler.prototype.createIfNot = function () {\n  this.create(true);\n}; // If we're altering the table, we need to one-by-one\n// go through and handle each of the queries associated\n// with altering the table's schema.\n\n\nTableCompiler.prototype.alter = function () {\n  var addColBuilders = this.getColumns();\n  var addColumns = addColBuilders.map(function (col) {\n    return col.toSQL();\n  });\n  var alterColBuilders = this.getColumns('alter');\n  var alterColumns = alterColBuilders.map(function (col) {\n    return col.toSQL();\n  });\n  var addColumnTypes = this.getColumnTypes(addColumns);\n  var alterColumnTypes = this.getColumnTypes(alterColumns);\n  this.addColumns(addColumnTypes);\n  this.alterColumns(alterColumnTypes, alterColBuilders);\n  this.columnQueries(addColumns);\n  this.columnQueries(alterColumns);\n  this.alterTable();\n};\n\nTableCompiler.prototype.foreign = function (foreignData) {\n  if (foreignData.inTable && foreignData.references) {\n    var keyName = foreignData.keyName ? this.formatter.wrap(foreignData.keyName) : this._indexCommand('foreign', this.tableNameRaw, foreignData.column);\n    var column = this.formatter.columnize(foreignData.column);\n    var references = this.formatter.columnize(foreignData.references);\n    var inTable = this.formatter.wrap(foreignData.inTable);\n    var onUpdate = foreignData.onUpdate ? (this.lowerCase ? ' on update ' : ' ON UPDATE ') + foreignData.onUpdate : '';\n    var onDelete = foreignData.onDelete ? (this.lowerCase ? ' on delete ' : ' ON DELETE ') + foreignData.onDelete : '';\n\n    if (this.lowerCase) {\n      this.pushQuery((!this.forCreate ? \"alter table \".concat(this.tableName(), \" add \") : '') + 'constraint ' + keyName + ' ' + 'foreign key (' + column + ') references ' + inTable + ' (' + references + ')' + onUpdate + onDelete);\n    } else {\n      this.pushQuery((!this.forCreate ? \"ALTER TABLE \".concat(this.tableName(), \" ADD \") : '') + 'CONSTRAINT ' + keyName + ' ' + 'FOREIGN KEY (' + column + ') REFERENCES ' + inTable + ' (' + references + ')' + onUpdate + onDelete);\n    }\n  }\n}; // Get all of the column sql & bindings individually for building the table queries.\n\n\nTableCompiler.prototype.getColumnTypes = function (columns) {\n  return (0, _lodash.reduce)((0, _lodash.map)(columns, _lodash.first), function (memo, column) {\n    memo.sql.push(column.sql);\n    memo.bindings.concat(column.bindings);\n    return memo;\n  }, {\n    sql: [],\n    bindings: []\n  });\n}; // Adds all of the additional queries from the \"column\"\n\n\nTableCompiler.prototype.columnQueries = function (columns) {\n  var queries = (0, _lodash.reduce)((0, _lodash.map)(columns, _lodash.tail), function (memo, column) {\n    if (!(0, _lodash.isEmpty)(column)) return memo.concat(column);\n    return memo;\n  }, []);\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = queries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var q = _step.value;\n      this.pushQuery(q);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}; // Add a new column.\n\n\nTableCompiler.prototype.addColumnsPrefix = 'add column '; // All of the columns to \"add\" for the query\n\nTableCompiler.prototype.addColumns = function (columns, prefix) {\n  prefix = prefix || this.addColumnsPrefix;\n\n  if (columns.sql.length > 0) {\n    var columnSql = (0, _lodash.map)(columns.sql, function (column) {\n      return prefix + column;\n    });\n    this.pushQuery({\n      sql: (this.lowerCase ? 'alter table ' : 'ALTER TABLE ') + this.tableName() + ' ' + columnSql.join(', '),\n      bindings: columns.bindings\n    });\n  }\n}; // Alter column\n\n\nTableCompiler.prototype.alterColumnsPrefix = 'alter column ';\n\nTableCompiler.prototype.alterColumns = function (columns, colBuilders) {\n  if (columns.sql.length > 0) {\n    this.addColumns(columns, this.alterColumnsPrefix, colBuilders);\n  }\n}; // Compile the columns as needed for the current create or alter table\n\n\nTableCompiler.prototype.getColumns = function (method) {\n  var _this = this;\n\n  var columns = this.grouped.columns || [];\n  method = method || 'add';\n  var queryContext = this.tableBuilder.queryContext();\n  return columns.filter(function (column) {\n    return column.builder._method === method;\n  }).map(function (column) {\n    // pass queryContext down to columnBuilder but do not overwrite it if already set\n    if (!(0, _lodash.isUndefined)(queryContext) && (0, _lodash.isUndefined)(column.builder.queryContext())) {\n      column.builder.queryContext(queryContext);\n    }\n\n    return _this.client.columnCompiler(_this, column.builder);\n  });\n};\n\nTableCompiler.prototype.tableName = function () {\n  var name = this.schemaNameRaw ? \"\".concat(this.schemaNameRaw, \".\").concat(this.tableNameRaw) : this.tableNameRaw;\n  return this.formatter.wrap(name);\n}; // Generate all of the alter column statements necessary for the query.\n\n\nTableCompiler.prototype.alterTable = function () {\n  var alterTable = this.grouped.alterTable || [];\n\n  for (var i = 0, l = alterTable.length; i < l; i++) {\n    var statement = alterTable[i];\n\n    if (this[statement.method]) {\n      this[statement.method].apply(this, statement.args);\n    } else {\n      this.client.logger.error(\"Debug: \".concat(statement.method, \" does not exist\"));\n    }\n  }\n\n  for (var item in this.single) {\n    if (typeof this[item] === 'function') this[item](this.single[item]);\n  }\n};\n\nTableCompiler.prototype.alterTableForCreate = function (columnTypes) {\n  this.forCreate = true;\n  var savedSequence = this.sequence;\n  var alterTable = this.grouped.alterTable || [];\n  this.grouped.alterTable = [];\n\n  for (var i = 0, l = alterTable.length; i < l; i++) {\n    var statement = alterTable[i];\n\n    if ((0, _lodash.indexOf)(this.createAlterTableMethods, statement.method) < 0) {\n      this.grouped.alterTable.push(statement);\n      continue;\n    }\n\n    if (this[statement.method]) {\n      this.sequence = [];\n      this[statement.method].apply(this, statement.args);\n      columnTypes.sql.push(this.sequence[0].sql);\n    } else {\n      this.client.logger.error(\"Debug: \".concat(statement.method, \" does not exist\"));\n    }\n  }\n\n  this.sequence = savedSequence;\n  this.forCreate = false;\n}; // Drop the index on the current table.\n\n\nTableCompiler.prototype.dropIndex = function (value) {\n  this.pushQuery(\"drop index\".concat(value));\n}; // Drop the unique\n\n\nTableCompiler.prototype.dropUnique = TableCompiler.prototype.dropForeign = function () {\n  throw new Error('Method implemented in the dialect driver');\n};\n\nTableCompiler.prototype.dropColumnPrefix = 'drop column ';\n\nTableCompiler.prototype.dropColumn = function () {\n  var _this2 = this;\n\n  var columns = helpers.normalizeArr.apply(null, arguments);\n  var drops = (0, _lodash.map)((0, _lodash.isArray)(columns) ? columns : [columns], function (column) {\n    return _this2.dropColumnPrefix + _this2.formatter.wrap(column);\n  });\n  this.pushQuery((this.lowerCase ? 'alter table ' : 'ALTER TABLE ') + this.tableName() + ' ' + drops.join(', '));\n}; // If no name was specified for this index, we will create one using a basic\n// convention of the table name, followed by the columns, followed by an\n// index type, such as primary or index, which makes the index unique.\n\n\nTableCompiler.prototype._indexCommand = function (type, tableName, columns) {\n  if (!(0, _lodash.isArray)(columns)) columns = columns ? [columns] : [];\n  var table = tableName.replace(/\\.|-/g, '_');\n  var indexName = (table + '_' + columns.join('_') + '_' + type).toLowerCase();\n  return this.formatter.wrap(indexName);\n};\n\nvar _default = TableCompiler;\nexports.default = _default;\nmodule.exports = exports.default;","map":null,"metadata":{},"sourceType":"script"}